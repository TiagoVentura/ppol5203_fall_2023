[
  {
    "objectID": "weeks/week-08.html",
    "href": "weeks/week-08.html",
    "title": "Week 08",
    "section": "",
    "text": "Lectures Notes:\n\n\nSlides\n\n\nReadings"
  },
  {
    "objectID": "weeks/week-09.html",
    "href": "weeks/week-09.html",
    "title": "Week 09",
    "section": "",
    "text": "Lectures Notes:\n\n\nSlides\n\n\nReadings"
  },
  {
    "objectID": "weeks/week-04.html",
    "href": "weeks/week-04.html",
    "title": "Week 04",
    "section": "",
    "text": "We will cover these notebooks\n\nComprehension and Generators –  Jupyter Notebook \nFile Management –  Jupyter Notebook \nData as Nested lists –  Jupyter Notebook \nNumpy –  Jupyter Notebook \n\nConditional on time, we will start pandas:\n\nIntro do Pandas –  Jupyter Notebook"
  },
  {
    "objectID": "weeks/week-04.html#lectures-notes",
    "href": "weeks/week-04.html#lectures-notes",
    "title": "Week 04",
    "section": "",
    "text": "We will cover these notebooks\n\nComprehension and Generators –  Jupyter Notebook \nFile Management –  Jupyter Notebook \nData as Nested lists –  Jupyter Notebook \nNumpy –  Jupyter Notebook \n\nConditional on time, we will start pandas:\n\nIntro do Pandas –  Jupyter Notebook"
  },
  {
    "objectID": "weeks/week-04.html#slides",
    "href": "weeks/week-04.html#slides",
    "title": "Week 04",
    "section": "Slides",
    "text": "Slides\n\nTBD"
  },
  {
    "objectID": "weeks/week-04.html#readings",
    "href": "weeks/week-04.html#readings",
    "title": "Week 04",
    "section": "Readings",
    "text": "Readings\n\nRequired Readings\nPDS VanderPlas\n\nCh. 2: Introduction to Numpy - Python Data Science Handbook - VanderPlas, Jake\n\nPDA Wes McKinney, Chapter 3\n\nList, Set, and Dictionary Comprehensions\nFile Management System\n\nAdditional Readings\nfor-loop-vs-list-comprehension-vs-high-order-functions"
  },
  {
    "objectID": "weeks/week-10.html",
    "href": "weeks/week-10.html",
    "title": "Week 10",
    "section": "",
    "text": "Lectures Notes:\n\n\nSlides\n\n\nReadings"
  },
  {
    "objectID": "weeks/week-11.html",
    "href": "weeks/week-11.html",
    "title": "Week 11",
    "section": "",
    "text": "Lectures Notes:\n\n\nSlides\n\n\nReadings"
  },
  {
    "objectID": "weeks/week-05.html",
    "href": "weeks/week-05.html",
    "title": "Week 05",
    "section": "",
    "text": "Intro do Pandas –  Jupyter Notebook \nLoading and Writing Data in Pandas –  Jupyter Notebook \nTidy Data and Data Wrangling in Pandas –  Jupyter Notebook \nJoining Data in Pandas –  Jupyter Notebook \nMiscelanneous: Piping, Missing data and others –  Jupyter Notebook"
  },
  {
    "objectID": "weeks/week-05.html#lectures-notes",
    "href": "weeks/week-05.html#lectures-notes",
    "title": "Week 05",
    "section": "",
    "text": "Intro do Pandas –  Jupyter Notebook \nLoading and Writing Data in Pandas –  Jupyter Notebook \nTidy Data and Data Wrangling in Pandas –  Jupyter Notebook \nJoining Data in Pandas –  Jupyter Notebook \nMiscelanneous: Piping, Missing data and others –  Jupyter Notebook"
  },
  {
    "objectID": "weeks/week-05.html#slides",
    "href": "weeks/week-05.html#slides",
    "title": "Week 05",
    "section": "Slides",
    "text": "Slides\nTBD"
  },
  {
    "objectID": "weeks/week-05.html#readings",
    "href": "weeks/week-05.html#readings",
    "title": "Week 05",
    "section": "Readings",
    "text": "Readings\nSuggested Readings\n\nPDS VanderPlas\nCh. 4: Data Manipulation with Pandas\nTidy Data in Python\nTidy Data by Hadley Wickham in R\n\nAnd all our lecture notes!\n\nAdditional Resources and Suggested Materials\n\nPython Pandas Tutorial: A Complete Introduction for Beginners\nData Wrangling with Pandas Cheat Sheet - pandas.pydata.org\ndplyr-style Data Manipulation with Pipes in Python - Allen, Akinkunle\nPython Pandas vs. R Dplyr - The Full Cheatsheet - Martin Šiklar\nMethods Chaining in Pandas\n\nExercises in Pandas"
  },
  {
    "objectID": "weeks/week-13.html",
    "href": "weeks/week-13.html",
    "title": "Week 13",
    "section": "",
    "text": "Lectures Notes:\n\n\nSlides\n\n\nReadings"
  },
  {
    "objectID": "weeks/week-07.html",
    "href": "weeks/week-07.html",
    "title": "Week 07",
    "section": "",
    "text": "Lectures Notes:\n\n\nSlides\n\n\nReadings"
  },
  {
    "objectID": "weeks/week-06.html",
    "href": "weeks/week-06.html",
    "title": "Week 06",
    "section": "",
    "text": "Lectures Notes:\n\n\nSlides\n\n\nReadings"
  },
  {
    "objectID": "weeks/week-12.html",
    "href": "weeks/week-12.html",
    "title": "Week 12",
    "section": "",
    "text": "Lectures Notes:\n\nInstruction for setting up the course infra-structure.\nUsing Jupyter Notebooks: Notebook,  Download \nUsing Quarto for Python and R:\nBasics of Command Line:\n\n\n\nSlides\n\nTBD\n\n\n\nReadings"
  },
  {
    "objectID": "weeks/week-02.html",
    "href": "weeks/week-02.html",
    "title": "Week 02",
    "section": "",
    "text": "Lecture Notes\n\n\n\nSlides\n\n\n\nReadings\n\nRequired Readings\n\nThe Plain Person’s Guide to Plain Text Social Science - Healy, Kieran\n\nCh. 1: Introduction\nCh. 2: Keep a Record\nCh. 3: Write and Edit\nCh. 4: Reproduce Work\n\nPro Git - Chacon & Straub\n\nCh. 1: Getting Started\n\nRead 1.1 - 1.3\n\nCh. 2: Git Basics\n\nOnly read 2.1 - 2.5\n\nCh. 3: Git Branching\n\n\nAdditional Resources and Suggested Materials\n\nMore on Git/Github in Pro Git:\n\nRead 1.4 - 1.7 for help on installation and commandline\nRead Ch. 6 for more information regarding Git + Github.\n\nGitHub for Atom - github.atom.io\nCh. 13 Detect Git from RStudio -Happy Git with R - Bryan, Jenny & Jim Hester"
  },
  {
    "objectID": "weeks/week-03.html",
    "href": "weeks/week-03.html",
    "title": "Week 03",
    "section": "",
    "text": "Intro to Python - OOP, Data Types, and Collectors –  Quarto Notebook  –  Jupyter Notebook \nIntro to Python II - Control Statements and Functions –  Quarto Notebook  –  Jupyter Notebook"
  },
  {
    "objectID": "weeks/week-03.html#lectures-notes",
    "href": "weeks/week-03.html#lectures-notes",
    "title": "Week 03",
    "section": "",
    "text": "Intro to Python - OOP, Data Types, and Collectors –  Quarto Notebook  –  Jupyter Notebook \nIntro to Python II - Control Statements and Functions –  Quarto Notebook  –  Jupyter Notebook"
  },
  {
    "objectID": "weeks/week-03.html#slides",
    "href": "weeks/week-03.html#slides",
    "title": "Week 03",
    "section": "Slides",
    "text": "Slides\n\nTBD"
  },
  {
    "objectID": "weeks/week-03.html#required-readings",
    "href": "weeks/week-03.html#required-readings",
    "title": "Week 03",
    "section": "Required Readings",
    "text": "Required Readings\n\nFrom Miller, Brad, and David Ranum, Problem Solving with Algorithms and Data Structures using Python\n\nGetting Started with Data\nControl Structure\nException Handling\nDefining Functions\n\nFrom [Wes McKinney, Python for Data Analysis]\n\nChapter 2: Python Language Basics, IPython, and Jupyter Notebooks\nChapter 2: Built-In Data Structures, Functions, and Files\n\nMutable vs Immutable Objects in Python - Mohan, Megha"
  },
  {
    "objectID": "weeks/week-03.html#additional-code",
    "href": "weeks/week-03.html#additional-code",
    "title": "Week 03",
    "section": "Additional Code",
    "text": "Additional Code\n\nData Carpentry\n\nPython Fundamentals\nRepeated Actions with Loops\nMaking Choices\nCreating Functions\nStoring Multiple Values in Lists"
  },
  {
    "objectID": "weeks/week-01.html",
    "href": "weeks/week-01.html",
    "title": "Week 01",
    "section": "",
    "text": "Lectures Notes:\n\nInstructions for setting up the course infra-structure.\nUsing Jupyter Notebooks: html,  Download \nUsing Quarto for Python and R html,  Download \nBasics of Command Line: html,  Download \n\n\n\nSlides\n\nWeek 01:Introduction, Installations, IDEs, Command line\n\n\n\nReadings\nThe readings for this week will be a mix of:\nA more general introduction to data science from a applied perspective (which you can call Data Science and Public Policy, Data Science for Public Good, or Computational Social Science in academic spaces)\nRequired Readings\n\nBit by Bit: Social Research in the Digital Age By Mathew Salganik + Introduction + Observing Behavior\nA Three-Step Guide to Training Computational Social Science Ph.D. Students for Academic and Non-Academic Careers - By Aniket Kesari, Jae Yeon Kim, Sono Shah, Taylor Brown, Tiago Ventura and Tina Law\n\nBest Practices in Programming, IDEs and Files Management:\nRequired Readings\n\nJupyter Notebook for Beginners: A tutorial Pryke, Benjamin - www.dataquest.io\nUsing Python with RStudio and reticulate: here and here\n\nAdditional\n\nMore on RStudio + Reticulate\nR & Python: A Love Storsy - rstudio.com\nRStudio 1.2 Preview: Reticulated Python\nOn using LaTex to write math in markdown - docx2latex.com"
  },
  {
    "objectID": "weeks/week-14.html",
    "href": "weeks/week-14.html",
    "title": "Week 14",
    "section": "",
    "text": "Lectures Notes:\n\n\nSlides\n\n\nReadings"
  },
  {
    "objectID": "problemset.html",
    "href": "problemset.html",
    "title": "Problem Sets",
    "section": "",
    "text": "Problem Set\n\n\nContent\n\n\nDate Assigned\n\n\nDue Date\n\n\n\n\n\n\nProblem Set 1\n\n\nVersion Control, Workflow and Reproducibility: Or a bit of Git & GitHub\n\n\n09/12/2023\n\n\nBefore EOD Friday Week 3\n\n\n\n\nProblem Set 02\n\n\nCore Programming Concepts in Python\n\n\n09/26/2023\n\n\nBefore EOD Friday Week 5\n\n\n\n\nProblem Set 03\n\n\nData Wrangling in Pandas\n\n\n10/10/2023\n\n\nBefore EOD Friday Week 7\n\n\n\n\nProblem Set 04\n\n\nUnestructure data, Scrapping, and more pandas\n\n\n10/24/2023\n\n\nBefore EOD Friday Week 9\n\n\n\n\nProblem Set 05\n\n\nWorking with text data\n\n\n11/07/2023\n\n\nBefore EOD Friday Week 11\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "lecture_notes/week-01/minimal_example_python.html",
    "href": "lecture_notes/week-01/minimal_example_python.html",
    "title": "Minimal Example Python",
    "section": "",
    "text": "Here you add your text as markdown."
  },
  {
    "objectID": "lecture_notes/week-01/minimal_example_python.html#minimal-example-of-using-python-with-quarto",
    "href": "lecture_notes/week-01/minimal_example_python.html#minimal-example-of-using-python-with-quarto",
    "title": "Minimal Example Python",
    "section": "",
    "text": "Here you add your text as markdown."
  },
  {
    "objectID": "lecture_notes/week-01/minimal_example_python.html#code",
    "href": "lecture_notes/week-01/minimal_example_python.html#code",
    "title": "Minimal Example Python",
    "section": "Code",
    "text": "Code\nYou will use the same code block for any language. You just need to change language inside of the brackets {}\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy.stats as stats\nimport math\n\nmu = 0\nvariance = 1\nsigma = math.sqrt(variance)\nx = np.linspace(mu - 3*sigma, mu + 3*sigma, 100)\nplt.plot(x, stats.norm.pdf(x, mu, sigma))\nplt.show()\n\nModuleNotFoundError: No module named 'matplotlib'"
  },
  {
    "objectID": "lecture_notes/week-01/intro-to-quarto.html",
    "href": "lecture_notes/week-01/intro-to-quarto.html",
    "title": "Week 1: Introduction to Quarto for Python",
    "section": "",
    "text": "The purpose of this notebook is to show case the use of Quarto notebooks. It will cover:\n\nBrief introduction to Quarto Notebooks\nRunning R with Quarto Notebooks\nRunning Python with Quarto Notebooks + reticulate\n\nSee Quarto’s website for a more in-depth coverage of the framework."
  },
  {
    "objectID": "lecture_notes/week-01/intro-to-quarto.html#my-personal-tldr-about-quarto",
    "href": "lecture_notes/week-01/intro-to-quarto.html#my-personal-tldr-about-quarto",
    "title": "Week 1: Introduction to Quarto for Python",
    "section": "My personal TLDR about Quarto",
    "text": "My personal TLDR about Quarto\nQuarto was developed by Posit (the new name of RStudio). It represents the effort of RStudio to become a language agnostic IDE for Data Science.\nQuarto main promise is to allow data scientists to run many different languages using the same notebook structure. For the purpose of our course, we will use mostly Jupyter Notebooks, since those are still dominant among Python developers.\nHowever, as you are learning Python and R at the same time throughout your DSPP courses, I advice you to be comfortable with Quarto and use it the same tool to run both R and Python."
  },
  {
    "objectID": "lecture_notes/week-01/intro-to-quarto.html#quick-tutorial-for-rstudio",
    "href": "lecture_notes/week-01/intro-to-quarto.html#quick-tutorial-for-rstudio",
    "title": "Week 1: Introduction to Quarto for Python",
    "section": "Quick tutorial for RStudio",
    "text": "Quick tutorial for RStudio\nThis is what RStudio looks like when you open it for the first time.\n\n\n\n\n\nTop left pane (input/script)\nThis is your code editor. Here you enter code in any file type (.py, .r, .qmd) you are working on. If not working with notebooks, this is just gonna be a plain text file but with a extension that run the commands.\nFor example, enter 2 + 2 in your script and run a line of code by pressing command + enter (Mac) or Ctrl + enter (PC). This is a huge advantage of Rstudio over Jupyter. You can run your code line by line, instead of running the entire cell.\nBottom left pane (output/console)\nThis is the console. It is pretty much like when you open Python/R from the Command line.\nIn the console, the prompt &gt; looks like a greater than symbol. If your prompt begins to look like a + symbol by mistake, simply click in your console and press the esc key on your keyboard as many times as necessary to return to the prompt.\nRstudio uses + when code is broken up across multiple lines and is still expecting more code. A line of code does not usually end until Rstudio finds an appropriate stop parameter or punctuation that completes some code such as a closed round parenthesis ), square bracket ], curly brace }, or quotation mark '.\nIf the output in your console gets too messy, you can clear it by pressing control + l on both Mac and PC. This will not erase any saved data - it will simply make your console easier to read.\nTop right pane (global environment)\nThis is your environment pane. All objects you create will be displayed here.\nBottom right pane (files, plots, packages, and help)\nHere you find useful tabs for navigating your file system, displaying plots, installing packages, and viewing help pages. Press the control key and a number (1 through 9) on your keyboard to shortcut between these panes and tabs."
  },
  {
    "objectID": "lecture_notes/week-01/course_infrastructure.html",
    "href": "lecture_notes/week-01/course_infrastructure.html",
    "title": "Week 1: Course Infrastructure",
    "section": "",
    "text": "Throughout the semester, we will use a combination of tools. This a summary of the main tools:\n\nCommandLine: primarily to interact with git, install programs and run a few scripts\nPython3: for programming taks\nGit/Github: for version control, reproucibility and for sharing materials\nJupyter Notebooks: as a main IDE to work with Python\nQuarto via RStudio: as a secondary IDE (you can make your primary if you prefer) to coding in Python/R/SQL\nSlack: for communication.\n\nLet’s cover how to set up each of these tools in your local machines.\n\n\n\n\n\n\nWarning\n\n\n\nIf you run into issues, please reach out to the Teaching Assistant for assistance\n\n\n\n\nAt times, we’ll use a unix-based commandline. The commandline will feature into our discussion on using git and also running Python programs. If you use a Mac or a Linux operating system, then a functioning commandline comes with your operating system. For Apple machines, this is the Terminal.\nFor Windows (specifically Windows 10), you can enable Linux Bash shell. The following offers a tutorial on how to do this.\nIf you’re using a version of Windows that pre-dates version 10, then Git Bash offers a program will allow you to use git commands from your windows machine.\nLater in the first class, we will cover some concepts of working with the commandline. You can get a full notebook with a intro to commandline in the materials for week 1\n\n\n\nWe’ll use Python3 throughout this course. Below are instructions for downloading Python3 using commandline packages manager (Homebrew for mac, Chocolatey for windows).\n\nInstalling Python3 using Homebrew on a Mac (Apple)\nInstalling Python3 using Chocolatey on a PC (Windows)\n\nAn alternative way to install Python3 is to download an Anaconda distribution. I will use pip rather than conda in the instruction for downloading Python modules. These are simply two ways of downloading and managing open-source software packages. Choose which ever works best for you\nMost computers already have python3 installed. You can check if that is your case through your commandline\npython3 --version\nOn some versions of Windows, you may need to use py instead of python3:\npy --version\nIn either case, the output of this command should be something like Python 3.8.5\n\n\n\nOnce you have Python3 on your computer, you can install a Jupyter Notebook. If you downloaded Python3 using Anaconda, then Jupyter Notebook comes with the distribution and requires no further installation on your part. If you are not using Anaconda, you can install Jupyter notebook running the following code using your commandline.\n# on your command line\npip install jupyter\nYou can then activate a Jupyter Notebook from the commandline by typing:\n# on your command line\njupyter notebook\n\n\nHere is my workflow to open Jupyter Notebooks using the commandline.\n\nOpen the terminal\nNavigate (using cd) to the folder you want to be the root of your jupyter notebook\nOpen the notebook (jupyter notebook)\n\nIt looks like this if I were to open a notebook in the folder I have for this course\n# open terminal\ncd ppol_5203\njupyter notebook\n\n\n\nIf you installed Python using Anaconda distribution system (here: https://www.anaconda.com/products/individual). You can open Jupyter through a point-and-click system. It take forever, but it works!\nIn the lecture notes, you can also find a Introduction to Jupyter notebook. We will cover this in the first class of the course.\n\n\n\n\nA quick digression of the R vs Python debate\nFor some of your classes in the Data Science and Public Policy Masters, you will be using R. Some data scientists and computational social scientists have strong beleifs as to which langugae is better. I, and the DSPP faculty, do not subscribe to that view. Most techniques that are relevent for applied data science can be done in either language.\nIn my personal opinion, R outperforms Python in data manipulation tasks, visualization and statistical modeling. This is because R started out as a statistical programming environment, and that heritage is still visible. Meanwhile, Python started our a general purpose programming language, which was heavily adopted by computer scientists, which means Python outperforms on abstraction, machine learning tasks, working with more complex data types.\nMost importantly, you will be using more one language compared to the other conditional on your career path and the type of tasks you end up working with. If you end up in a team full of computer scientists, it is more likely Python will be your favored language. If you move to work more with social scientists, R will probably be more heavily used. There is no need to chose now. Learn both and broad your horizons. As general programming languages, learning both requires almost the same amount of effort of learning one in isolation.\nBack to the course infrastructure\nIn your classes that are focused on using R, RStudio will be your main IDE. However, RStudio isn’t just for R. It can handle a number of different languages. We can use Python in RStudio using the reticulate package.\nI create a full notebook to teach you how to use Python in Rstudio. Check the intro do quarto notebook. Let’s cover some of the installation steps here:\nTo install RStudio, download from the following link . reticulate is an R package that allows one run a Python REPL in the R console. In addition, it allows one to read in and use Python code, and pass data between R and and Python. The following provides instructions on installing reticulate.\nWith reticulate, you can use Rstudio as a IDE for Python. Another option is to use Quarto (the next-generation version of R Markdown) as an unified framework to generate notebooks with text + code. If you’re an R Markdown user, you will see how Quarto is just an extension of the capabilities that were previously provided by R Markdown. Now, instead of .rmd files, we have .qmd files. Quarto is already installed with RStudio.\n\n\n\nWe’ll go over more Git/GitHub instructions during the second class session. Before that session:\n\nInstall Git if it’s not installed already\nCreate a GitHub account if you don’t have one already (any email and free subscription is fine)\n\n\n\n\nOur course will make use of Slack for internal communication. Enter in our workspace with this link: (https://join.slack.com/t/ppol5203fall2023/shared_invite/zt-1z99dee8l-jxY3HCwfEkxY1H6ZUNedEA).\nWhen should you use slack?\n\nInteract with the TAs\nAsk questions to your colleagues\nShare links that are interesting to the discussions in class.\n\nWhen I should not use slack?\n\nIf you have a question you believe will require a longer conversation, I prefer if you can stop by at my office hours\n\nRemember, you don’t need to let me know you are going to my office hours. Just stop by!\nIf you’re new to Slack, check out this tutorial. In the first class, I’ll send out the invitation for everyone to join Slack and we’ll discuss how to use it."
  },
  {
    "objectID": "lecture_notes/week-01/course_infrastructure.html#commandline",
    "href": "lecture_notes/week-01/course_infrastructure.html#commandline",
    "title": "Week 1: Course Infrastructure",
    "section": "",
    "text": "At times, we’ll use a unix-based commandline. The commandline will feature into our discussion on using git and also running Python programs. If you use a Mac or a Linux operating system, then a functioning commandline comes with your operating system. For Apple machines, this is the Terminal.\nFor Windows (specifically Windows 10), you can enable Linux Bash shell. The following offers a tutorial on how to do this.\nIf you’re using a version of Windows that pre-dates version 10, then Git Bash offers a program will allow you to use git commands from your windows machine.\nLater in the first class, we will cover some concepts of working with the commandline. You can get a full notebook with a intro to commandline in the materials for week 1"
  },
  {
    "objectID": "lecture_notes/week-01/course_infrastructure.html#python3",
    "href": "lecture_notes/week-01/course_infrastructure.html#python3",
    "title": "Week 1: Course Infrastructure",
    "section": "",
    "text": "We’ll use Python3 throughout this course. Below are instructions for downloading Python3 using commandline packages manager (Homebrew for mac, Chocolatey for windows).\n\nInstalling Python3 using Homebrew on a Mac (Apple)\nInstalling Python3 using Chocolatey on a PC (Windows)\n\nAn alternative way to install Python3 is to download an Anaconda distribution. I will use pip rather than conda in the instruction for downloading Python modules. These are simply two ways of downloading and managing open-source software packages. Choose which ever works best for you\nMost computers already have python3 installed. You can check if that is your case through your commandline\npython3 --version\nOn some versions of Windows, you may need to use py instead of python3:\npy --version\nIn either case, the output of this command should be something like Python 3.8.5"
  },
  {
    "objectID": "lecture_notes/week-01/course_infrastructure.html#jupyter-notebooks",
    "href": "lecture_notes/week-01/course_infrastructure.html#jupyter-notebooks",
    "title": "Week 1: Course Infrastructure",
    "section": "",
    "text": "Once you have Python3 on your computer, you can install a Jupyter Notebook. If you downloaded Python3 using Anaconda, then Jupyter Notebook comes with the distribution and requires no further installation on your part. If you are not using Anaconda, you can install Jupyter notebook running the following code using your commandline.\n# on your command line\npip install jupyter\nYou can then activate a Jupyter Notebook from the commandline by typing:\n# on your command line\njupyter notebook\n\n\nHere is my workflow to open Jupyter Notebooks using the commandline.\n\nOpen the terminal\nNavigate (using cd) to the folder you want to be the root of your jupyter notebook\nOpen the notebook (jupyter notebook)\n\nIt looks like this if I were to open a notebook in the folder I have for this course\n# open terminal\ncd ppol_5203\njupyter notebook\n\n\n\nIf you installed Python using Anaconda distribution system (here: https://www.anaconda.com/products/individual). You can open Jupyter through a point-and-click system. It take forever, but it works!\nIn the lecture notes, you can also find a Introduction to Jupyter notebook. We will cover this in the first class of the course."
  },
  {
    "objectID": "lecture_notes/week-01/course_infrastructure.html#rstudio-reticulatequarto",
    "href": "lecture_notes/week-01/course_infrastructure.html#rstudio-reticulatequarto",
    "title": "Week 1: Course Infrastructure",
    "section": "",
    "text": "A quick digression of the R vs Python debate\nFor some of your classes in the Data Science and Public Policy Masters, you will be using R. Some data scientists and computational social scientists have strong beleifs as to which langugae is better. I, and the DSPP faculty, do not subscribe to that view. Most techniques that are relevent for applied data science can be done in either language.\nIn my personal opinion, R outperforms Python in data manipulation tasks, visualization and statistical modeling. This is because R started out as a statistical programming environment, and that heritage is still visible. Meanwhile, Python started our a general purpose programming language, which was heavily adopted by computer scientists, which means Python outperforms on abstraction, machine learning tasks, working with more complex data types.\nMost importantly, you will be using more one language compared to the other conditional on your career path and the type of tasks you end up working with. If you end up in a team full of computer scientists, it is more likely Python will be your favored language. If you move to work more with social scientists, R will probably be more heavily used. There is no need to chose now. Learn both and broad your horizons. As general programming languages, learning both requires almost the same amount of effort of learning one in isolation.\nBack to the course infrastructure\nIn your classes that are focused on using R, RStudio will be your main IDE. However, RStudio isn’t just for R. It can handle a number of different languages. We can use Python in RStudio using the reticulate package.\nI create a full notebook to teach you how to use Python in Rstudio. Check the intro do quarto notebook. Let’s cover some of the installation steps here:\nTo install RStudio, download from the following link . reticulate is an R package that allows one run a Python REPL in the R console. In addition, it allows one to read in and use Python code, and pass data between R and and Python. The following provides instructions on installing reticulate.\nWith reticulate, you can use Rstudio as a IDE for Python. Another option is to use Quarto (the next-generation version of R Markdown) as an unified framework to generate notebooks with text + code. If you’re an R Markdown user, you will see how Quarto is just an extension of the capabilities that were previously provided by R Markdown. Now, instead of .rmd files, we have .qmd files. Quarto is already installed with RStudio."
  },
  {
    "objectID": "lecture_notes/week-01/course_infrastructure.html#git",
    "href": "lecture_notes/week-01/course_infrastructure.html#git",
    "title": "Week 1: Course Infrastructure",
    "section": "",
    "text": "We’ll go over more Git/GitHub instructions during the second class session. Before that session:\n\nInstall Git if it’s not installed already\nCreate a GitHub account if you don’t have one already (any email and free subscription is fine)"
  },
  {
    "objectID": "lecture_notes/week-01/course_infrastructure.html#slack",
    "href": "lecture_notes/week-01/course_infrastructure.html#slack",
    "title": "Week 1: Course Infrastructure",
    "section": "",
    "text": "Our course will make use of Slack for internal communication. Enter in our workspace with this link: (https://join.slack.com/t/ppol5203fall2023/shared_invite/zt-1z99dee8l-jxY3HCwfEkxY1H6ZUNedEA).\nWhen should you use slack?\n\nInteract with the TAs\nAsk questions to your colleagues\nShare links that are interesting to the discussions in class.\n\nWhen I should not use slack?\n\nIf you have a question you believe will require a longer conversation, I prefer if you can stop by at my office hours\n\nRemember, you don’t need to let me know you are going to my office hours. Just stop by!\nIf you’re new to Slack, check out this tutorial. In the first class, I’ll send out the invitation for everyone to join Slack and we’ll discuss how to use it."
  },
  {
    "objectID": "lecture_notes/week-03/week-03_iter_control_functions.html",
    "href": "lecture_notes/week-03/week-03_iter_control_functions.html",
    "title": "Week 3: Intro to Python - Control Statements and Functions",
    "section": "",
    "text": "For the second half of the week three class, we will go over some concepts that are very general over any programming language. These are:\n\nExplore iterating through containers using loops\nUsing logical operators for comparisons.\nControl the behavior of code when iterating using control statements.\nDefining functions to make code more flexible, debuggable, and readable."
  },
  {
    "objectID": "lecture_notes/week-03/week-03_iter_control_functions.html#learning-objectives",
    "href": "lecture_notes/week-03/week-03_iter_control_functions.html#learning-objectives",
    "title": "Week 3: Intro to Python - Control Statements and Functions",
    "section": "",
    "text": "For the second half of the week three class, we will go over some concepts that are very general over any programming language. These are:\n\nExplore iterating through containers using loops\nUsing logical operators for comparisons.\nControl the behavior of code when iterating using control statements.\nDefining functions to make code more flexible, debuggable, and readable."
  },
  {
    "objectID": "lecture_notes/week-03/week-03_iter_control_functions.html#comparison-operators",
    "href": "lecture_notes/week-03/week-03_iter_control_functions.html#comparison-operators",
    "title": "Week 3: Intro to Python - Control Statements and Functions",
    "section": "Comparison Operators",
    "text": "Comparison Operators\nComparison operators check whether a relationship holds between two objects. Since the relationship either holds or doesn’t hold, these operators always return Boolean values. See below for a list of these operators\n\n\n\nOperator\nProperty\n\n\n\n\n==\n(value) equivalence\n\n\n&gt;\ngreater than\n\n\n&lt;\nstrictly less than\n\n\n&lt;=\nless than or equal\n\n\n&gt;\nstrictly greater than\n\n\n&gt;=\ngreater than or equal\n\n\n!=\nNot Equals\n\n\nis\nobject identity\n\n\nis not\nnegated object identity\n\n\nin\nmembership in\n\n\nnot in\nnegated membership in\n\n\n\n\n# Some examples\n\n# Comparisons\nx = 7\ny = 6\n\n# simple comparisons\nx &gt;= y\nx &gt; y\nx &lt; y\nx &lt;= y\n\n# \"in\" for contains\n\"d\" in [\"x\",\"a\",\"v\"]\n\nFalse\n\n\n\nBoolean Comparison\nAnother type of operators are those that take as input boolen types and return as outputs the data types. These are often super useful when we are working with recoding of multiple variables. See table below:\n\n\n\nOperator\nLogical Operation\n\n\n\n\nand\nConjunction\n\n\nor\nDisjunction\n\n\nnot\nNegation\n\n\n\n\n# examples\n\n# and\nTrue and False\n\n# or\nTrue  or False\n\nTrue\n\n\n\nAll this is barely scratching the surface For a in-depth discussion of comparison operators in python, see here."
  },
  {
    "objectID": "lecture_notes/week-03/week-03_iter_control_functions.html#conditional-statements",
    "href": "lecture_notes/week-03/week-03_iter_control_functions.html#conditional-statements",
    "title": "Week 3: Intro to Python - Control Statements and Functions",
    "section": "Conditional Statements",
    "text": "Conditional Statements\nAny programming language needs statements that controls the sequence of execution of a particular piece of code. These statements are called control statements, and they enable you to write programs that can perform different actions based on different inputs or situations. A for loop is a type of of control statement.\nThe most common control statements are conditional statements. The name speaks by itself: these statements control when a program run conditional on meeting a certain criteria. The most popular conditional statements are if, elif, and else statements.\nThese statements have the following structure:\n\nif &lt;logical statement&gt;:\n  ~~~~ CODE ~~~~\nelif &lt;logical statement&gt;:\n  ~~~~ CODE ~~~~\nelse:\n  ~~~~ CODE ~~~~\n\n\n\n\n\n\n\nWarning\n\n\n\nNotice the indentation in the code blocks of the conditional statements!\n\n\n\nif statement\nThe if statement evaluates an expression, and if that expression is True, it then executes the following indented code. If the expression is False, nothing is executed\n\n# most basic statement\nif True:\n    print(\"This statement is True\")\n\nThis statement is True\n\n\n\n# with a number\nx = 5\nif x &gt; 10: # state some condition\n    print(\"High\")\n\n\n\nelse statement\nThe else statement executes only if the evaluation of the if and all the elif expressions are False. It is a negation statement by nature.\n\n# with a number\nx = 5\nif x &gt; 10: # state some condition\n    print(\"High\")\nelse:\n    print(\"Low\")\n\nLow\n\n\n\n\nelif statement\nelif stands for else if in plain english. It allows the programmer to concatenate multiple conditional statements. Only after the if statement expression is False, the elif statement is evaluated and executed\n\nx = 5\nif x is None:\n    print(\"A\")\nelif x &lt; 0:\n    print(\"B\")\nelif x &gt;10:\n    print(\"C\")\nelse:\n    print(\"D\")\n\nD\n\n\nNotice you can arrive at the same behavior with nested if statements.\n\nx=5\n\n# same, but uglier version of the control flow above. \nif x is none:\n  print(\"A\")\n    if x &lt; 0:\n      print(\"B\")\n        if x &gt;10:\n          print(\"C\")\nelse:\n  print(\"D\")\n\nIndentationError: unexpected indent (1315603005.py, line 6)"
  },
  {
    "objectID": "lecture_notes/week-03/week-03_iter_control_functions.html#iteration",
    "href": "lecture_notes/week-03/week-03_iter_control_functions.html#iteration",
    "title": "Week 3: Intro to Python - Control Statements and Functions",
    "section": "Iteration",
    "text": "Iteration\nA basic building block of any program is to be to be able to repeat some code over and over again. Whether it is to collect data for a list of websites, apply some function to a sequence of dataframes, or retrieve information form a set of different models, we are often interested as data scientist in repeating a certain action through a sequence of unit. This process is called iteration and it is often performed using a loop function.\n\nfor loops\nIteration in a basic sense is simply taking one item at a time from a collection. We start at the beginning of the collection and mover through it until we reach the end. Any time we use a loop we are going over each and every item in collection\nIn python, we can iterator over any non-scaler class with an iter() associated method. Examples are:\n\nlists\nstrings\ndictionaries\nfile connections\ngrouped pandas df\n\n\nfor loop with lists\n\n# create a list\nmy_list = [1, 2, 3, 4, 5]\n\n# iterate\nfor m in my_list:\n  print(m)\n\n1\n2\n3\n4\n5\n\n\n\n\nfor loop with strings\n\n# create a list\nmy_string = \"Georgetown\"\n\n# iterate\nfor letter in my_string:\n  print(letter)\n\nG\ne\no\nr\ng\ne\nt\no\nw\nn\n\n\n\n\nfor loop with range()\nAnother container with the type of sequences used to express arithmetic progression of integers\n\n# one value 0 to 10\nfor i in range(10):\n    print(i)\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nThe instance from a range() is just a simple iterator\n\n# create a range\niter_ = range(10)\niter_[0]\niter_[1]\n\n# we can convert to a list to see the object\nlist(iter_)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\nfor loop with enumerate()\nThe enumerate function converts an iterable object in a tuple with a index and the iterator\n\n# create a string\niterable = \"McCourt\"\n\n# enumerate\nfor index, letter in enumerate(iterable):\n  print(f'index = {index}; value == {letter}')\n\nindex = 0; value == M\nindex = 1; value == c\nindex = 2; value == C\nindex = 3; value == o\nindex = 4; value == u\nindex = 5; value == r\nindex = 6; value == t\n\n\n\nA for loop is just another control statement. At its most basic sense, as a programmer, you are asking for a particular program to iterate over a sequence of values.\n\n\n\n\nIn-depth understanding of loops\nWe just learned in practive how loops work. Let’s break down a bit more so that we actually grasp what is going on behind the scenes here.\n\nSyntax\nFirst, let’s fully understand the syntax of a loop. A loop had the following syntax:\nfor &lt;var&gt; in &lt;iterable&gt;:\n    &lt;statement(s)&gt;\n\n&lt;iterable&gt;: is a collection of objects. This is the container through which our loop is navigating element-wise\n&lt;statement(s)&gt;: this is the juice. It is a sequence of code that describes what is the action our program wants to repeat for each component of the iterable. Notice, &lt;statements&gt; in the loop body are denoted by indentation, as with all Python control structures.\n&lt;var&gt;: it is a local value for every of the next element in  each time through the loop.\n\n\n\nIterator\niterable is any object that contains the __iter__ methods. This method returns an “iterator” object. An iterator object has a special method called __next__(), which summons each item in the collection one at a time.\n\n# create a iterable\nmy_list = [\"UFPA\", \"UERJ\", \"UMD\", \"NYU\", \"Georgetown\"]\nprint(my_list)\n\n# convert to a iterator\niter(my_list)\nmy_list.__iter__()\n\n# iterate over the elements\niter_my_list = iter(my_list)\n\n# first\nnext(iter_my_list)\n\n# first\nnext(iter_my_list)\n\n# second\nnext(iter_my_list)\n\n# third\nnext(iter_my_list)\n\n# fourth\nnext(iter_my_list)\n\n# firth: stop iteration\nnext(iter_my_list)\n\n['UFPA', 'UERJ', 'UMD', 'NYU', 'Georgetown']\n\n\nStopIteration: \n\n\nSo what does a for loop do?\n\nThe for statement calls iter() on the container object (e.g. a list).\nThe function returns an iterator object that defines the method __next__() which accesses elements in the container one at a time.\nWhen there are no more elements, __next__() raises a StopIteration exception which tells the for loop to terminate.\n\n\n\n\nWhile loops\nFor loops are literally iterations. While loops are all about repetitions. These loops are super useful when we have some target and want to keep our program running up to certain threeshold. For example, while loops are heavily used in maximization functions, in which we keep the algorithm running until our error function is at a minimum/maximum.\n\nx = 0\nwhile x &lt; 5:\n    print(\"This\")\n    x += 1\n\nThis\nThis\nThis\nThis\nThis\n\n\nRemember to increment your condition and avoid an infinite loop."
  },
  {
    "objectID": "lecture_notes/week-03/week-03_iter_control_functions.html#user-defined-functions",
    "href": "lecture_notes/week-03/week-03_iter_control_functions.html#user-defined-functions",
    "title": "Week 3: Intro to Python - Control Statements and Functions",
    "section": "User Defined Functions",
    "text": "User Defined Functions\nMost often when we start our first steps as data scientists (particularly for those like me coming from a non-computer science background), we learn to write code in two basic steps: write code sequentially to solve your immediate needs, and reuse this code for similar tasks. With that in mind, our code usually becomes unecessarily long, repetitive and hard to read.\nWhat is the problem of a long and repetitive code? You can execute the same task with a long, repetitive code than with a modular, function-based implementation. However, a sequential and repetitive code exposes you as a data scientist to errors you want to avoid. These are:\n\nLack of general utility.\nNeed to edit/copy/paste your code every time you want to reuse it.\nNeed to re-write the code when you need to make small extenstion\nMore important: The more code a program contains, the more chance there is for something to go wrong, and the harder the code is to maintain.\n\nFor this reason, the single best thing you can do to make your code more professional is to encapsulate your code in smaller, independent parts. This is usually refereed as modularity in programming, and it is achieved by writing your own user-defined functions.\n\n\n\n\n\n\nWhen should I transform my code into a function?\n\n\n\nOnce you find yourself copying the same code more than once or twice, it’s time to sink some time into writing a function.\n\n\n\nFunctions in Python.\nA function is a chunk of code that performs some operation. Python comes with several built-in functions. These are standard functions (type(), str(), float(), etc..) or methods associated with native python classes (str.capitalize(),list.append(), etc…)\nIn addition you can create your own functions through:\n\nfunction definition with def()\nanonymous functions with lambda functions\n\n\ndef()\n\n# create a square function\ndef square(x):\n    y = x*x\n    return y\n\n# run\nsquare(10)\n\n100\n\n\nThe code block above has the following elements:\n\ndef: keyword for generating a function\n\ndef + some_name + () + : to set up a function header\n\nArguments: things we want to feed into the function and do something to.\nreturn: keyword for returning a specific value from a function\n\n\nDocstrings\nHelp yourself and others who will use your functions in the future. A good practice is to use docstrings to describe your function behavior, inputs, and outputs. Docstrings are strings that occur as the first statement within a named function block.\n\ndef function_name(input):\n    '''\n    Your docstring goes here.\n    '''\n    |\n    |\n    | Function block\n    |\n    |\n    return something \n\nThe goal of the docstring is to tell us what the function does. We can request a functions docstring using the help() function.\n\ndef square(x):\n  '''\n  Takes the square of a number\n  input: int object\n  outpur: int object\n  '''\n  y = x*x\n  return y\n\nhelp(square)\n\nHelp on function square in module __main__:\n\nsquare(x)\n    Takes the square of a number\n    input: int object\n    outpur: int object\n\n\n\n\n\n\nArguments\nArguments are all the input values that lie inside the parentheses.\n`def fun(argument_1,argument_2):`\nWe can supply default values to one or all arguments; in doing so, we’ve specified a default argument.\n`def fun(argument_1 = \"default 1\",argument_2 = \"default 2\"):`\n\ndef fun(a,b=\"\"):\n  pass\n\n\nargument a is called a positional argument (*arg). We provide value to it by matching the position in the sequence.\nargument b is called a keyword argument (**kwargs). Because we give it a default value.\n\nKeyword arguments must come after positional arguments, or python will throw a SyntaxError.\n\n\n\n\n\n\nWarning\n\n\n\nWhat is the pass statement in the chunk above?\n\n\n\n\nReturning Multiple Arguments\nPython function can return multiple arguments. That possibility gives you a lot of flexibility when programming in Python. This is an important difference between Python and R, since R functions don’t return multiple objects in the strict sense.\n\ndef raise_both(value1, value2):\n  \"\"\"Raise value1 to the power of value2\n  and vice versa.\"\"\"\n  new_value1 = value1 ** value2\n  new_value2 = value2 ** value1\n  return (new_value1, new_value2)\n\nvalue1, value2 = raise_both(2, 3)\nprint(value1)\nprint(value2)\n\n8\n9\n\n\nUnder the hood, you are using a tuple as a return object, and unpacking the tuple in the assignment.\n\n\nScoping\nA scope is part of the program where an object or name may be accessible in Python. Not all objects can be accessed in the same way, and live in the same environment.\nThere are three main scopes we are interested :\n\nLocal: name is defined inside the current function\nGlobal: Any and all names defined at the top level of a module.\nBuilt-in: names “built into” python through the builtins module\n\n\n\n\n\n\n\nTip\n\n\n\nNote that for loops and code blocks do not introduce new nested scopes. We can alter the rules slightly when need by using the global and local calls\n\n\nLet’s check this code showing case a local variables\n\n# new_val is local \n\n#create function\ndef square(value):\n  \"\"\"Returns the square of a number.\"\"\"\n  new_val = value ** 2\n  return new_val\n# run\nsquare(3)\n\n# print new_val\nprint(new_val)\n\nNameError: name 'new_val' is not defined\n\n\n\n# create a global variabl\nnew_val = 10\n\n# write the same function (nor necessary)\ndef square(value):\n  \"\"\"Returns the square of a number.\"\"\"\n  new_val = value ** 2\n  return new_val\n\n# run\nsquare(3)\n\n# print var\nprint(new_val)\n\n10\n\n\nWhat if we want to access a global variables from a local scope?\n\na = 0\n\ndef my_function():\n    print(a)\n\nmy_function()\n\n0\n\n\nAnd what about this program?\n\na = 0\n\ndef my_function():\n    a = 3\n    print(a)\n\nmy_function()\n\nprint(a)\n\n3\n0\n\n\nAnd modify a global variable?\n\na = 0\n\ndef my_function():\n    global a\n    a = 3\n    print(a)\n\nmy_function()\n\nprint(a)\n\n3\n3\n\n\n\n\n\n\n\n\nWarning\n\n\n\n\nFrom Python Documentation: it is usually very bad practice to access global variables from inside functions, and even worse practice to modify them. This makes it difficult to arrange our program into logically encapsulated parts which do not affect each other in unexpected ways. If a function needs to access some external value, we should pass the value into the function as a parameter.\n\n\n\nRefer to the python documentation for a more detailed outline of scoping conditions in python.\n\n\nLambda functions\nIn addition to user defined functions, Python also supports the use of anonymous functions, or so-called lambda functions. These are essentially straightforward functions that comprise only one statement, and the value returned by that statement becomes the function’s result. These functions are referred to as anonymous because they lack a formal name or identifier. To define such functions, the lambda keyword is employed, which serves the sole purpose of indicating the declaration of an anonymous function.\n  `lambda x: x*2`\n  `lambda args: return value`\n\n# user-defined\ndef square(value):\n  \"\"\"Returns the square of a number.\"\"\"\n  new_val = value ** 2\n  return new_val\n\n#lambda function\ntype(lambda x: x^2)\n\nfunction\n\n\n\n\n\n\n\n\nWarning\n\n\n\nNotice that the output of a lambda function is a function. This function returns the return_value of the lambda functions\n\n\nUsing a lambda function\n\n#create a funnction from a lambda function -- this makes no sense\nsquare=lambda x: x**2\nsquare(2)\n\n# encapsulating on parenthesis\n(lambda x: x**2)(2)\n\n4\n\n\nBy itself, lambda functions are not super powerful. However, these shortcuts become very handy when combined with higher-order functions, which are functions that take other functions as input. For example, using the map() high-order function that applies a function to ALL elements in the sequence.\n\nnums = [48, 6, 9, 21, 1]\nsquare_all = map(lambda x: x ** 2, nums)\nprint(list(square_all))\n\n[2304, 36, 81, 441, 1]"
  },
  {
    "objectID": "lecture_notes/week-03/week-03_data_types.html",
    "href": "lecture_notes/week-03/week-03_data_types.html",
    "title": "Week 3: Intro to Python - OOP, Data Types, and Collectors",
    "section": "",
    "text": "We will start this class with a broader overview of what Object-Oriented Programming means. This might sound a bit generic, but it is a super important concept for you to grasp and build a more general understanding of Python.\nAfter that, we will go more into a classic introduction to Python, with a focus on Data Types and Data Collections\n\nGet some intuition behind objects in Python\nExplore the different built-in data types.\nExamine how to look up values in collection data type using an index and/or key\nLearn about the issues that can arise when copying mutable objects and how to resolve them.\n\nAfter that, we will go over some concepts that are very general over any programming language:\n\nExplore iterating through containers using loops\nUsing logical operators for comparisons.\nControl the behavior of code when iterating using control statements.\nDefining functions to make code more flexible, debuggable, and readable.\n\n\n\nPython is an object-oriented programming language (OOP) where the object plays a more fundamental role for how we structure a program. Specifically, OOP allows one to bundle properties and behavior into individual objects. In Python, objects can hold both the data and the methods used to manipulate that data.\nAs you are progressing in the DSPP, you are also being introduced to R. R, one the other hand, is a functional programming language where functions are objects and data is manipulated using functions.\nAt first glance, the distinction is subtle, but the way we build programs in R and Python differs considerably. In practice, the OOP vs. Functional distinction changes how one engages with objects instantiated in the environment. In Python, methods (functions) are self-contained in the object; whereas in R functions are external to the object. In other words, while much of the work in R consists on writing functions that are stores outside of classes/objects, in Python, you can borrow from general classes, inherit their methods/functions, or just add new functionalities to objects created by others.\nAt the core of OOP are the objects. They are also important in R, but not as flexible as in Python\n\n\n= is the assignment operator in Python. Different from R, in which there are multiple assignment operators, in Python, you only have the (=) assignment operator\n\nx = 4\n\nThis simple act of creating an object in Python comprise three different, and interesting actions.\n\nWhen using it, a reference is assigned to an object (e.g. below, x references the object 4 in the statement x = 4). This is the name of the object as it is saved in your environment. But notice this is not how the object is saved in your machine\n\n\n# in your machine\nid(x)\n\n4298289120\n\n\nIn Python, variable names:\n\ncan include letters, digits, and underscores\ncannot start with a digit\nare case sensitive.\n\nUse names that make sense. This simple action will make you code much easier to read.\n\nAn objects type is defined at runtime (also known as “duck typing”). Python is a dynamically typed language, which differs from other languages where type must be made explicit (e.g. C++, Java). Type cannot be changed once an object is created (coercing an object into a different type actually creates a new object).\n\n\n# Creating object in C\nint result = 0;\n\n\nObjects are instantiated upon assignment. An objects class provides a blueprint for object behavior and functionality. We use the pointer . to access an objects methods and attributes.\n\n\n# what is the class?\ntype(x)\n\n# Access methods (behaviors) using .\nx.bit_length()\n\n# see all\ndir(x)\n\n['__abs__',\n '__add__',\n '__and__',\n '__bool__',\n '__ceil__',\n '__class__',\n '__delattr__',\n '__dir__',\n '__divmod__',\n '__doc__',\n '__eq__',\n '__float__',\n '__floor__',\n '__floordiv__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__getnewargs__',\n '__gt__',\n '__hash__',\n '__index__',\n '__init__',\n '__init_subclass__',\n '__int__',\n '__invert__',\n '__le__',\n '__lshift__',\n '__lt__',\n '__mod__',\n '__mul__',\n '__ne__',\n '__neg__',\n '__new__',\n '__or__',\n '__pos__',\n '__pow__',\n '__radd__',\n '__rand__',\n '__rdivmod__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__rfloordiv__',\n '__rlshift__',\n '__rmod__',\n '__rmul__',\n '__ror__',\n '__round__',\n '__rpow__',\n '__rrshift__',\n '__rshift__',\n '__rsub__',\n '__rtruediv__',\n '__rxor__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__sub__',\n '__subclasshook__',\n '__truediv__',\n '__trunc__',\n '__xor__',\n 'as_integer_ratio',\n 'bit_length',\n 'conjugate',\n 'denominator',\n 'from_bytes',\n 'imag',\n 'numerator',\n 'real',\n 'to_bytes']\n\n\n\n\nEvery time we create an object, this objects inherits a class. This is what we called instantiating.\nClasses are used to create user-defined data structures. A class is a blueprint for how something should be defined. It doesn’t actually contain any data. The Dog class specifies that a name and an age are necessary for defining a dog, but it doesn’t contain the name or age of any specific dog.\nAn instance is a realization of a particular class. And this instance inherits the characteristics of its class. Imagine we have a class called dog(), every time I use this class to create a new, concrete dog (object), I am capturing a instance, or a realization of this abstract class.\nClasses have two major components:\n\nAttributes: these are constant features, data, a characteristic of the broader class\nMethods: these are actions, behaviors of this class.\n\nBoth attributes and methods are accessed through . function. But\nWe will see later how to create our own classes. Most important now is for you to understand that every object in python has a class, and every realization of this class inherits both attributes and methods.\nLet’s see a quick example here.\n\n# create a class\nclass Example():\n  def __init__ (self, name):\n    self.name = name\n  def hello(self):\n    print('Hi, I am ' + self.name)\n\n# Instatiate\nme = Example(name=\"Tiago\")\n\n# Attributes\nme.name\n\n# method\nme.hello()\n\nHi, I am Tiago\n\n\nHere we can print out all the different methods using the dir() function (which provides an internal directory of all the methods contained within the class). As we can see, there is a lot going on inside this single set object!\n\ndir(me)\n\n['__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n 'hello',\n 'name']\n\n\n\n\n\n\n\nThere are two ways of instantiating a data class in Python:\n\nLiterals: syntatic representation in Python, e.g. []\nConstructors: class constructors, e.g. list()\n\nPython comes with a number of built-in data types. When talking about data types, it’s useful to differentiate between:\n\nscalar types (data types that hold one piece of information, like a digit) and\ncollection types (data types that hold multiple pieces of information).\n\nThese built-in data types are the building blocks for more complex data types, like a pandas DataFrame (which we’ll cover later).\n\n\n\nScalar Data Types\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\nExample\nLiteral\nConstructor\n\n\n\n\nint\ninteger types\n4\nx = 4\nint(4)\n\n\nfloat\n64-bit floating point numbers\n4.567\nx = 4.567\nfloat(4)\n\n\nbool\nboolean logical values\nTrue\nx = True\nbool(0)\n\n\nNone\nnull object (serves as a valuable place holder)\nNone\nx = None\n\n\n\n\n\nNote two things from the above table:\n\nthe literal occurs through assignment, and\nthe constructor can be used to coerce one data type into another.\n\n\n\nHere we assign an integer (3) to the object x .\n\n# int\nx = 3\nx\ntype(x)\n\nint\n\n\n\n\n\nNow let’s coerce the integer to a float using the constructor float(). float represent real numbers with both an integer and fractional component\n\n# float\nfloat(x)\nx\n\n3\n\n\nNote that behavior of the object being coerced depends both on the initial class and the output class.\n\n#int\nx=3\n\n# add a int + float = float\ntype(x+3.0)\n\nfloat\n\n\n\n\n\nBoolean objects that are equal to True are truthy (True), and those equal to False are falsy (False). Numerically, int values equal to zero are False, and larger than zero are True\n\n# literal\nx=True\n\n#constructor\nbool(0)\n\nFalse\n\n\n\n\n\nFinally, all scalar data types are immutable, meaning they can’t be changed after assignment. When we make changes to a data type, say by coercing it to be another type as we do above, we’re actually creating a new object. We can see this by looking at the object id.\n\nid() tells us the “identity” of an object. That shouldn’t mean anything to you. Just know that when an object id is the same, it’s referencing the same data in the computer. We’ll explore the implications of this when we look at copying.\n\n\nx = 4\nid(x) \n\n4298289120\n\n\nHere we coerce x to be a float and then look up its id(). As we can see, there is a new number associated with it. This means x is a different object after coercion.\n\nid(float(x))\n\n140314976681488\n\n\n\n\n\nPython knows how to behave given the methods assigned to the object when we create an instance. The methods dictate how different data types deal with similar operations (such as addition, multiplication, comparative evaluations, ect.).\nUsing what we learned from OOP, it means that for every class, we have specific methods. These methods can have specific names – any user-defined function – or they can same universal names (Magic or Dunder Methods). See the addition example with int instances.\n\n# create int\nx=4\n\n# add literally\nx + 4\n\n# what is happening under the hood? \nx.__add__(4)\n\n8\n\n\nEvery class has a self-contained __add__ methods. For this reason, the output of adding two int or an int and a float are different\n\n\n\n\nCollection Data Types\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\nExample\nMutable\nLiteral\nConstructor\n\n\n\n\nlist\nheterogeneous sequences of objects\n[1,\"2\",True]\n✓\nx = [\"c\",\"a\",\"t\"]\nx = list(\"cat\")\n\n\nstr\nsequences of characters\n\"A word\"\n✘\nx = \"12345\"\nx = str(12345)\n\n\ntuples\nheterogeneous sequence of objects\n(1,2)\n✘\nx = (1,2)\nx = tuple([1,2])\n\n\nsets\nunordered collection of distinct objects\n{1,2}\n✓\nx = {1,2}\nx = set([1,2])\n\n\ndicts\nassociative array of key/value mappings\n{\"a\": 1}\nkeys ✘values ✓\nx = {'a':1}\nx = dict(a = 1)\n\n\n\nEach built-in collection data type in Python is distinct in important ways. Recall that an object’s class defines how the object behaves with operators and its methods. I’ll explore some of the differences in behavior for each class type so we can see what this means in practice\n\n\n\nNote the column referring to Mutable and Immutable collection types. Simply put, mutable objects can be changed after it is created, immutable objects cannot be changed. All the scalar data types are immutable. Even when we coerced objects into a different class, we aren’t changing the existing object, we are creating a new one.\nSome collection types, however, allow us to edit the data values contained within without needing to create a new object. This can allow us to effectively use the computer’s memory. It can also create some problems down the line if we aren’t careful (see the tab on copies).\nIn practice, mutability means we can alter values in the collection on the fly.\n\nmy_list = [\"sarah\",\"susan\",\"ralph\",\"eddie\"]\nid(my_list)\n\n140315540564672\n\n\n\nmy_list[1] = \"josh\"\nmy_list\nid(my_list) # Still the same object, even though we changed something in it\n\n140315540564672\n\n\nImmutability, on the other hand, means that we cannot alter values after the object is created. Python will throw an error at us if we try.\n\nmy_tuple =(\"sarah\",\"susan\",\"ralph\",\"eddie\")\nmy_tuple[1] = \"josh\"\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\n\n\nLists allow for heterogeneous membership in the various object types. This means one can hold many different data types (even other collection types!). In a list, one can change items contained within the object after creating the instance.\n\nx = [1, 2.2, \"str\", True, None] \nx\n\n[1, 2.2, 'str', True, None]\n\n\nA list constructor takes in an iterable object as input. (We’ll delve more into what makes an object iterable when covering loops, but the key is that the object must have an .__iter__() method.)\n\nlist(\"This\")\n\n['T', 'h', 'i', 's']\n\n\nAt it’s core, a list is a bucket for collecting different types of information. This makes it useful for collecting data items when one needs to store them. For example, we can store multiple container types in a list.\n\na = (1,2,3,4) # Tuple\nb = {\"a\":1,\"b\":2} # Dictionary\nc = [1,2,3,4] # List\n\ntogether = [a,b,c] # Combine these different container objects into a single list\ntogether\n\n[(1, 2, 3, 4), {'a': 1, 'b': 2}, [1, 2, 3, 4]]\n\n\nA list class has a range of specific methods geared toward querying, counting, sorting, and adding/removing elements in the container. For a list of all the list methods, see here.\nLet’s explore some of the common methods used.\n\ncountry_list = [\"Russia\",\"Latvia\",\"United States\",\"Nigeria\",\"Mexico\",\"India\",\"Costa Rica\"]\n\nInserting values\nOption 1: use the .append() method.\n\ncountry_list.append(\"Germany\")\ncountry_list\n\n['Russia',\n 'Latvia',\n 'United States',\n 'Nigeria',\n 'Mexico',\n 'India',\n 'Costa Rica',\n 'Germany']\n\n\nOption 2: use the + (add) operator.\n\ncountry_list = country_list + ['Canada']\ncountry_list\n\n['Russia',\n 'Latvia',\n 'United States',\n 'Nigeria',\n 'Mexico',\n 'India',\n 'Costa Rica',\n 'Germany',\n 'Canada']\n\n\n\nAddition means “append”?: Recall that an objects class dictates how it behaves in place of different operators. A list object has a .__add__() method built into it that provides instructions for what the object should do when it encounters + operator. Likewise, when it encounters a * multiplication operator and so on. This is why it’s so important to know the class that you’re using. Different object classes == different behavior.\n\nYou can also combine list through the reference names\n\nmore_countries = [\"Brazil\", \"Argentina\"]\ncountry_list + more_countries\n\n['Russia',\n 'Latvia',\n 'United States',\n 'Nigeria',\n 'Mexico',\n 'India',\n 'Costa Rica',\n 'Germany',\n 'Canada',\n 'Brazil',\n 'Argentina']\n\n\nDeleting values\nOption 1: use the del operator + index.\n\n# Drop Latvia\ndel country_list[1]\ncountry_list\n\n['Russia',\n 'United States',\n 'Nigeria',\n 'Mexico',\n 'India',\n 'Costa Rica',\n 'Germany',\n 'Canada']\n\n\nOption 2: use the .remove() method\n\ncountry_list.remove(\"Nigeria\")\ncountry_list\n\n['Russia',\n 'United States',\n 'Mexico',\n 'India',\n 'Costa Rica',\n 'Germany',\n 'Canada']\n\n\nSorting values\n\ncountry_list.sort()\ncountry_list\n\n['Canada',\n 'Costa Rica',\n 'Germany',\n 'India',\n 'Mexico',\n 'Russia',\n 'United States']\n\n\n\n\n\nStrings are containers too. String elements can be accessed using an index, much like objects in a list (See the tab on indices and keys).\n\ns = \"This is a string\"\ns[:4]\n\n'This'\n\n\nThe literal for a string is quotations: '' or \"\". When layering quotations, one needs to opt for the quotation type different than the one used to instantiate the string object.\n\ns = 'This is a \"string\"'\nprint(s)\n\ns = \"This is a 'string'\"\nprint(s)\n\nThis is a \"string\"\nThis is a 'string'\n\n\nA Multiline string can be created using three sets of quotations. This is useful when writing documentation for a function.\n\ns2 = '''\nThis is a long string!\n    \n    With many lines\n    \n    Many. Lines.\n'''\nprint(s2)\n\n\nThis is a long string!\n    \n    With many lines\n    \n    Many. Lines.\n\n\n\nString are quite versatile in Python! In fact, many of the manipulations that we like to perform on strings, such as splitting text up (also known as “tokenizing”), cleaning out punctuation and characters we don’t care for, and changing the case (to name a few) are built into the string class method.\nFor example, say we wanted to convert a string to upper case.\n\nstr1 = \"the professor is here!\"\nstr1.upper()\n\n'THE PROFESSOR IS HERE!'\n\n\nOr remove words.\n\nstr1.replace(\"professor\",\"student\")\n\n'the student is here!'\n\n\nThis is just a taste. The best way to learn what we can do with a string is to use it. We’ll deal with strings all the time when dealing with public policy data. So keep in mind that the str data type is a powerful tool in Python. For a list of all the str methods, see here.\n\n\n\nLike a list, a tuple allows for heterogeneous membership among the various scalar data types. However, unlike a list, a tuple is immutable, meaning you cannot change the object after creating it.\nThe literal for a tuple is the parentheses ()\n\nmy_tuple = (1,\"a\",1.2,True)\nmy_tuple\n\n(1, 'a', 1.2, True)\n\n\nThe constructor is tuple(). Like the list constructor, tuple() an iterable object (like a list) as an input.\n\nmy_tuple = tuple([1,\"a\",1.2,True])\nmy_tuple\n\n(1, 'a', 1.2, True)\n\n\nTuples are valuable if you want a data value to be fixed, such as if it were an index on a data frame, denoting a unit of analysis, or key on a dictionary. Tuples pop up all the time in the wild when dealing with more complex data modules, like Pandas. So we’ll see them again and again.\nOne nice thing that tuples allow for is unpacking. Unpacking allows one to deconstruct the tuple object into named references (i.e. assign the values in the tuple to their own objects). This allows for flexibility regarding which objects we want when performing sequential operations, like iterating.\n\nmy_tuple = (\"A\",\"B\",\"C\")\n\n# Here we're unpacking the three values into their own objects\nobj1, obj2, obj3 = my_tuple \n\n# Now let's print each object\nprint(obj1)\nprint(obj2)\nprint(obj3)\n\nA\nB\nC\n\n\nAlso, like a list, a tuple can store different collection data types as well as the scalar types. For example, we can store multiple container types in a tuple.\n\na = (1,2,3,4) # Tuple\nb = {\"a\":1,\"b\":2} # Dictionary\nc = [1,2,3,4] # List\n\ntogether = (a,b,c) # Combine these different container objects into a single tuple\ntogether\n\n((1, 2, 3, 4), {'a': 1, 'b': 2}, [1, 2, 3, 4])\n\n\nFor a list of all the tuple methods, see here.\n\n\n\nA set is an unordered collection of unique elements (this just means there can be no duplicates). set is a mutable data type (elements can be added and removed). Moreover, the set methods allow for set algebra. This will come in handy if we want to know something about unique values and membership.\nThe literal for set is the brackets {}.1\n\nmy_set = {1,2,3,3,3,4,4,4,5,1}\nmy_set\n\n{1, 2, 3, 4, 5}\n\n\nThe constructor is set(). As before, it takes an iterable object as an input.\n\nnew_set1 = set([1,2,4,4,5])\nnew_set1\n\nnew_set2 = set(\"Georgetown\")\nnew_set2\n\n{'G', 'e', 'g', 'n', 'o', 'r', 't', 'w'}\n\n\nIn the above, we can see that order isn’t a thing for a set.\nWe can add elemets to a set using the .add() or .update() methods.\n\nmy_set.add(6)\nmy_set\n\nmy_set.update({8})\nmy_set\n\n{1, 2, 3, 4, 5, 6, 8}\n\n\nWhere a set really shines is with the set operations. Say we had a set of country names.\n\ncountries = {\"nigeria\",\"russia\",\"united states\",\"canada\"}\n\nAnd we wanted to see which countries from our set were in another set (say another data set). Not a problem for a set!\n\nother_data = {\"nigeria\",\"netherlands\",\"united kingdom\",\"canada\"}\n\nWhich countries are in both sets?\n\ncountries.intersection(other_data)\n\n{'canada', 'nigeria'}\n\n\nWhich countries are in our data but not in the other data?\n\ncountries.difference(other_data)\n\n{'russia', 'united states'}\n\n\nNote that values in a set cannot be accessed using an index.\n\nmy_set[1]\n\nTypeError: 'set' object is not subscriptable\n\n\nRather we either .pop() values out of the set.\n\nmy_set.pop()\n\n1\n\n\nOr we can .remove() specific values from the set.\n\nmy_set.remove(3)\nmy_set\n\n{2, 4, 5, 6, 8}\n\n\nFinally, note that sets can contain heterogeneous scalar types, but they cannot contain other mutable container data types.\n\nset_a = {.5,6,\"a\",None}\nset_a\n\n{0.5, 6, None, 'a'}\n\n\nIn set_b, the list object is mutable.\n\nset_b = {.5,6,\"a\",None,[8,5,6]}\n\nTypeError: unhashable type: 'list'\n\n\nAll this is barely scratching the surface of what we can do with sets. For a list of all the set methods, see here.\n\n\n\nA dictionary is the true star of the Python data types. dict is an associative array of key-value pairs. That means, we have some data (value) that we can quickly reference by calling its name (key). As we’ll see next week, this allows for a very efficient way to look data values, especially when the dictionary is quite large.\nThere is no intrinsic ordering to the keys, and keys can’t be changed once created (that is, the keys are immutable), but the values can be changed (assuming that the data type occupying the value spot is mutable, like a list). Finally, keys cannot be duplicated. Recall we’re going to use the keys to look up data values, so if those keys were the same, it would defeat purpose!\nThe literal for a dict is {:} as in {&lt;key&gt;:&lt;value&gt;}.\n\nmy_dict = {'a': 4, 'b': 7, 'c': 9.2}\nmy_dict\n\n{'a': 4, 'b': 7, 'c': 9.2}\n\n\nThe constructor is dict(). Note the special way we can designate the key value pairing when using the constructor.\n\nmy_dict = dict(a = 4.23, b = 10, c = 6.6)\nmy_dict\n\n{'a': 4.23, 'b': 10, 'c': 6.6}\n\n\nThe dict class has a number of methods geared toward listing the information contained within. To access the dict’s keys, use the .keys() method.\n\nmy_dict.keys()\n\ndict_keys(['a', 'b', 'c'])\n\n\nJust want the values? Use .values()\n\nmy_dict.values()\n\ndict_values([4.23, 10, 6.6])\n\n\nWant both? Use .items(). Note how the data comes back to us — as tuples nested in a list! This just goes to show you how intertwined the different data types are in Python.\n\nmy_dict.items()\n\ndict_items([('a', 4.23), ('b', 10), ('c', 6.6)])\n\n\nWe can combine dictionary with other data types (such as a list) to make an efficient and effective data structure.\n\ngrades = {\"John\": [90,88,95,86],\"Susan\":[87,91,92,89],\"Chad\":[56,None,72,77]}\n\nWe can use the keys for efficient look up.\n\ngrades[\"John\"]\n\n[90, 88, 95, 86]\n\n\nWe can also use the .get() method to get the values that correspond to a specific key.\n\ngrades.get(\"Susan\")\n\n[87, 91, 92, 89]\n\n\nUpdating Dictionaries\nWe can add new dictionary data entries using the .update() method.\n\nnew_entry = {\"Wendy\":[99,98,97,94]} # Another student dictionary entry with grades\ngrades.update(new_entry) # Update the current dictionary \ngrades\n\n{'John': [90, 88, 95, 86],\n 'Susan': [87, 91, 92, 89],\n 'Chad': [56, None, 72, 77],\n 'Wendy': [99, 98, 97, 94]}\n\n\nIn a similar fashion, we can update the dictionary directly by providing a new key entry and storing the data.\n\ngrades[\"Seth\"] = [66,72,79,81]\ngrades\n\n{'John': [90, 88, 95, 86],\n 'Susan': [87, 91, 92, 89],\n 'Chad': [56, None, 72, 77],\n 'Wendy': [99, 98, 97, 94],\n 'Seth': [66, 72, 79, 81]}\n\n\nOne can also drop keys by .pop()ing the key value pair out of the collection…\n\ngrades.pop(\"Seth\")\n\n[66, 72, 79, 81]\n\n\n…or deleting the key using the del operator.\n\ndel grades['Wendy']\ngrades\n\n{'John': [90, 88, 95, 86],\n 'Susan': [87, 91, 92, 89],\n 'Chad': [56, None, 72, 77]}\n\n\nLikewise, one can drop values by:\n\noverwriting the original data stored in the key\ndropping the key (and thus deleting the data value)\nclearing the dictionary (and deleting all the data values stored within. )\n\n\n# Example of using .clear()\ngrades.clear()\ngrades\n\n{}\n\n\nThis is barely scratching the surface. For a list of all the dict methods and all the things you can do with a dictionary, see here.\n\n\n\n\n\nLearning how to access the data types is a foundation of your fluency as a data scientist.\nAs you transition across different languages, keep track of accessing methods across different data types is actually quite challenging. You will definitely find yourself searching online many times for this. The important issue here is make an effort to understand general rules for acessing elements across languages and data types\n\n\nA first way to access elements in collectors is through their index position.\n\ndifferent from R, Python objects start its index at zero\n\n\n  # Define a list \n  x = [1, 2.2, \"str\", True, None]\n  \n  # first element in python\n  x[0]\n\n  # can see how many values are in our container with len()\n  len(x)\n  \n  # Can look up individual data values by referencing its location\n  x[3]\n  \n  # Python throws an error if we reference an index location that doesn't exist\n  x[7]\n  \n  # We use a negative index to count BACKWARDS in our collection data type.\n  x[-3]\n\nIndexError: list index out of range\n\n\nThis way to access data using index position is going to be very standard across a range of data type.\n\n# tuples\ntup = (1, 2, \"no\", True)\n\n# first element\ntup[0]\n\n# Last element\ntup[-1]\n\nTrue\n\n\n\n\n\nWe use the : operator to slice (i.e. select ranges of values). This works using the numerical indices we juat learned. Slicing in a nutshell goes like this :\n\n# To pull out values in position 1 and 2\nx[1:3]\n\n# When we leave left or right side blank, Python implicitly goes to the beginning or end\nx[:3]\nx[2:]\n\n# %% Keys -----------------------------------------\n\n  # Define a dictionary\n  grades = {\"John\":[90,88,95,86],\"Susan\":[87,91,92,89],\"Chad\":[56,None,72,77]}\n\n  # Unlike lists/tuples/sets, we use a key to look up a value in a dictionary\n  grades[\"John\"]\n  \n  # We can then index in the data structure housed in that key's value position\n  # as is appropriate for that data object\n  grades[\"John\"][1]\n\nIndentationError: unexpected indent (4043772330.py, line 11)\n\n\n\n\n\n\n\n\n\n\n# Copies with mutable objects -----------------------\n\n# Create a list object\nx = [\"a\",\"b\",\"c\",\"d\"]\n\n# Dual assignment: when objects reference the same data.\nx = y\nprint(id(x)) \nprint(id(y))\n\n# If we make a change in one\ny[1] = \"goat\"\n\n# That change is reflected in the other\nprint(x)\n\n# Because these aren't independent objects\n\n# We can get around this issue by making **copies**\ny = x.copy() # Here y is a copy of x.\n# This duplicates the data in memory, so that y and x are independent. \n\n# Three ways to make a copy:\n# (1) Use copy method\ny = x.copy()\n# (2) Use constructor\ny = list(x)\n# (3) Slice it\ny = x[:]\n\n\n# Copies with nested objects -----------------------\nnested_list = [[1,2,3],[4,7,88],[69,21,9.1]]\n\n# Create a shallow copy\nnew_list = nested_list.copy()\n\n# This copy only works for the \"first layer\" in the nested data structure.\nnew_list[0][1] = 1000\nprint(nested_list)\n\n# Creating a deep copy\n#import copy\nnew_list = copy.deepcopy(nested_list)\n\nNameError: name 'y' is not defined\n\n\n\n\n\nA basic building block of any program is to be to be able to repeat some code over and over again. Whether it is to collect data for a list of websites, apply some function to a sequence of dataframes, or retrieve information form a set of different models, we are often interested as data scientist in repeating a certain action through a sequence of unit. This process is called iteration and it is often performed using a loop function.\n\n\nIteration in a basic sense is simply taking one item at a time from a collection. We start at the beginning of the collection and mover through it until we reach the end. Any time we use a loop we are going over each and every item in collection\nIn python, we can iterator over any non-scaler class with an iter() associated method. Examples are:\n\nlists\nstrings\ndictionaries\nfile connections\ngrouped pandas df\n\n\n\n\n# create a list\nmy_list = [1, 2, 3, 4, 5]\n\n# iterate\nfor m in my_list:\n  print(m)\n\n1\n2\n3\n4\n5\n\n\n\n\n\n\n# create a list\nmy_string = \"Georgetown\"\n\n# iterate\nfor letter in my_string:\n  print(letter)\n\nG\ne\no\nr\ng\ne\nt\no\nw\nn\n\n\n\n\n\nAnother container with the type of sequences used to express arithmetic progression of integers\n\n# one value 0 to 10\nfor i in range(10):\n    print(i)\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nThe instance from a range() is just a simple iterator\n\n# create a range\niter_ = range(10)\niter_[0]\niter_[1]\n\n# we can convert to a list to see the object\nlist(iter_)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\n\nThe enumerate function converts an iterable object in a tuple with a index and the iterator\n\n# create a string\niterable = \"McCourt\"\n\n# enumerate\nfor index, letter in enumerate(iterable):\n  print(f'index = {index}; value == {letter}')\n\nindex = 0; value == M\nindex = 1; value == c\nindex = 2; value == C\nindex = 3; value == o\nindex = 4; value == u\nindex = 5; value == r\nindex = 6; value == t\n\n\n\n\n\n\nWe just learned in practive how loops work. Let’s break down a bit more so that we actually grasp what is going on behind the scenes here.\n\n\nFirst, let’s fully understand the syntax of a loop. A loop had the following syntax:\nfor &lt;var&gt; in &lt;iterable&gt;:\n    &lt;statement(s)&gt;\n\n&lt;iterable&gt;: is a collection of objects. This is the container through which our loop is navigating element-wise\n&lt;statement(s)&gt;: this is the juice. It is a sequence of code that describes what is the action our program wants to repeat for each component of the iterable. Notice, &lt;statements&gt; in the loop body are denoted by indentation, as with all Python control structures.\n&lt;var&gt;: it is a local value for every of the next element in  each time through the loop.\n\n\n\n\niterable is any object that contains the __iter__ methods. This method returns an “iterator” object. An iterator object has a special method called __next__(), which summons each item in the collection one at a time.\n\n# create a iterable\nmy_list = [\"UFPA\", \"UERJ\", \"UMD\", \"NYU\", \"Georgetown\"]\nprint(my_list)\n\n# convert to a iterator\niter(my_list)\nmy_list.__iter__()\n\n# iterate over the elements\niter_my_list = iter(my_list)\n\n# first\nnext(iter_my_list)\n\n# first\nnext(iter_my_list)\n\n# second\nnext(iter_my_list)\n\n# third\nnext(iter_my_list)\n\n# fourth\nnext(iter_my_list)\n\n# firth: stop iteration\nnext(iter_my_list)\n\n['UFPA', 'UERJ', 'UMD', 'NYU', 'Georgetown']\n\n\nStopIteration: \n\n\nSo what does a for loop do?\n\nThe for statement calls iter() on the container object (e.g. a list).\nThe function returns an iterator object that defines the method __next__() which accesses elements in the container one at a time.\nWhen there are no more elements, __next__() raises a StopIteration exception which tells the for loop to terminate.\n\n\n\n\n\nFor loops are literally iterations. While loops are all about repetitions. These loops are super useful when we have some target and want to keep our program running up to certain threeshold. For example, while loops are heavily used in maximization functions, in which we keep the algorithm running until our error function is at a minimum/maximum.\n\nx = 0\nwhile x &lt; 5:\n    print(\"This\")\n    x += 1\n\nThis\nThis\nThis\nThis\nThis\n\n\nRemember to increment your condition and avoid an infinite loop.\n\n\n\n\nComparison operators check whether a relationship holds between two objects. Since the relationship either holds or doesn’t hold, these operators always return Boolean values. See below for a list of these operators\n\n\n\nOperator\nProperty\n\n\n\n\n==\n(value) equivalence\n\n\n&gt;\ngreater than\n\n\n&lt;\nstrictly less than\n\n\n&lt;=\nless than or equal\n\n\n&gt;\nstrictly greater than\n\n\n&gt;=\ngreater than or equal\n\n\n!=\nNot Equals\n\n\nis\nobject identity\n\n\nis not\nnegated object identity\n\n\nin\nmembership in\n\n\nnot in\nnegated membership in\n\n\n\n\n# Some examples\n\n# Comparisons\nx = 7\ny = 6\n\n# simple comparisons\nx &gt;= y\nx &gt; y\nx &lt; y\nx &lt;= y\n\n# \"in\" for contains\n\"d\" in [\"x\",\"a\",\"v\"]\n\nFalse\n\n\n\n\nAnother type of operators are those that take as input boolen types and return as outputs the data types. These are often super useful when we are working with recoding of multiple variables. See table below:\n\n\n\nOperator\nLogical Operation\n\n\n\n\nand\nConjunction\n\n\nor\nDisjunction\n\n\nnot\nNegation\n\n\n\n\n# examples\n\n# and\nTrue and False\n\n# or\nTrue  or False\n\nTrue\n\n\n\nAll this is barely scratching the surface For a in-depth discussion of comparison operators in python, see here.\n\n\n\n\n\nAny programming language needs statements that controls the sequence of execution of a particular piece of code. These statements are called control statements, and they enable you to write programs that can perform different actions based on different inputs or situations. A for loop is a type of of control statement.\nThe most common control statements are conditional statements. The name speaks by itself: these statements control when a program run conditional on meeting a certain criteria. The most popular conditional statements are if, elif, and else statements.\nThese statements have the following structure:\n\n\n\n\n\n\nWarning\n\n\n\nNotice the indentation in the code blocks of the conditional statements!"
  },
  {
    "objectID": "lecture_notes/week-03/week-03_data_types.html#notion-of-object-oriented-programming",
    "href": "lecture_notes/week-03/week-03_data_types.html#notion-of-object-oriented-programming",
    "title": "Week 3: Intro to Python - OOP, Data Types, and Collectors",
    "section": "",
    "text": "Python is an object-oriented programming language (OOP) where the object plays a more fundamental role for how we structure a program. Specifically, OOP allows one to bundle properties and behavior into individual objects. In Python, objects can hold both the data and the methods used to manipulate that data.\nAs you are progressing in the DSPP, you are also being introduced to R. R, one the other hand, is a functional programming language where functions are objects and data is manipulated using functions.\nAt first glance, the distinction is subtle, but the way we build programs in R and Python differs considerably. In practice, the OOP vs. Functional distinction changes how one engages with objects instantiated in the environment. In Python, methods (functions) are self-contained in the object; whereas in R functions are external to the object. In other words, while much of the work in R consists on writing functions that are stores outside of classes/objects, in Python, you can borrow from general classes, inherit their methods/functions, or just add new functionalities to objects created by others.\nAt the core of OOP are the objects. They are also important in R, but not as flexible as in Python\n\n\n= is the assignment operator in Python. Different from R, in which there are multiple assignment operators, in Python, you only have the (=) assignment operator\n\nx = 4\n\nThis simple act of creating an object in Python comprise three different, and interesting actions.\n\nWhen using it, a reference is assigned to an object (e.g. below, x references the object 4 in the statement x = 4). This is the name of the object as it is saved in your environment. But notice this is not how the object is saved in your machine\n\n\n# in your machine\nid(x)\n\n4298289120\n\n\nIn Python, variable names:\n\ncan include letters, digits, and underscores\ncannot start with a digit\nare case sensitive.\n\nUse names that make sense. This simple action will make you code much easier to read.\n\nAn objects type is defined at runtime (also known as “duck typing”). Python is a dynamically typed language, which differs from other languages where type must be made explicit (e.g. C++, Java). Type cannot be changed once an object is created (coercing an object into a different type actually creates a new object).\n\n\n# Creating object in C\nint result = 0;\n\n\nObjects are instantiated upon assignment. An objects class provides a blueprint for object behavior and functionality. We use the pointer . to access an objects methods and attributes.\n\n\n# what is the class?\ntype(x)\n\n# Access methods (behaviors) using .\nx.bit_length()\n\n# see all\ndir(x)\n\n['__abs__',\n '__add__',\n '__and__',\n '__bool__',\n '__ceil__',\n '__class__',\n '__delattr__',\n '__dir__',\n '__divmod__',\n '__doc__',\n '__eq__',\n '__float__',\n '__floor__',\n '__floordiv__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__getnewargs__',\n '__gt__',\n '__hash__',\n '__index__',\n '__init__',\n '__init_subclass__',\n '__int__',\n '__invert__',\n '__le__',\n '__lshift__',\n '__lt__',\n '__mod__',\n '__mul__',\n '__ne__',\n '__neg__',\n '__new__',\n '__or__',\n '__pos__',\n '__pow__',\n '__radd__',\n '__rand__',\n '__rdivmod__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__rfloordiv__',\n '__rlshift__',\n '__rmod__',\n '__rmul__',\n '__ror__',\n '__round__',\n '__rpow__',\n '__rrshift__',\n '__rshift__',\n '__rsub__',\n '__rtruediv__',\n '__rxor__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__sub__',\n '__subclasshook__',\n '__truediv__',\n '__trunc__',\n '__xor__',\n 'as_integer_ratio',\n 'bit_length',\n 'conjugate',\n 'denominator',\n 'from_bytes',\n 'imag',\n 'numerator',\n 'real',\n 'to_bytes']\n\n\n\n\nEvery time we create an object, this objects inherits a class. This is what we called instantiating.\nClasses are used to create user-defined data structures. A class is a blueprint for how something should be defined. It doesn’t actually contain any data. The Dog class specifies that a name and an age are necessary for defining a dog, but it doesn’t contain the name or age of any specific dog.\nAn instance is a realization of a particular class. And this instance inherits the characteristics of its class. Imagine we have a class called dog(), every time I use this class to create a new, concrete dog (object), I am capturing a instance, or a realization of this abstract class.\nClasses have two major components:\n\nAttributes: these are constant features, data, a characteristic of the broader class\nMethods: these are actions, behaviors of this class.\n\nBoth attributes and methods are accessed through . function. But\nWe will see later how to create our own classes. Most important now is for you to understand that every object in python has a class, and every realization of this class inherits both attributes and methods.\nLet’s see a quick example here.\n\n# create a class\nclass Example():\n  def __init__ (self, name):\n    self.name = name\n  def hello(self):\n    print('Hi, I am ' + self.name)\n\n# Instatiate\nme = Example(name=\"Tiago\")\n\n# Attributes\nme.name\n\n# method\nme.hello()\n\nHi, I am Tiago\n\n\nHere we can print out all the different methods using the dir() function (which provides an internal directory of all the methods contained within the class). As we can see, there is a lot going on inside this single set object!\n\ndir(me)\n\n['__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n 'hello',\n 'name']"
  },
  {
    "objectID": "lecture_notes/week-03/week-03_data_types.html#data-types",
    "href": "lecture_notes/week-03/week-03_data_types.html#data-types",
    "title": "Week 3: Intro to Python - OOP, Data Types, and Collectors",
    "section": "",
    "text": "There are two ways of instantiating a data class in Python:\n\nLiterals: syntatic representation in Python, e.g. []\nConstructors: class constructors, e.g. list()\n\nPython comes with a number of built-in data types. When talking about data types, it’s useful to differentiate between:\n\nscalar types (data types that hold one piece of information, like a digit) and\ncollection types (data types that hold multiple pieces of information).\n\nThese built-in data types are the building blocks for more complex data types, like a pandas DataFrame (which we’ll cover later).\n\n\n\nScalar Data Types\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\nExample\nLiteral\nConstructor\n\n\n\n\nint\ninteger types\n4\nx = 4\nint(4)\n\n\nfloat\n64-bit floating point numbers\n4.567\nx = 4.567\nfloat(4)\n\n\nbool\nboolean logical values\nTrue\nx = True\nbool(0)\n\n\nNone\nnull object (serves as a valuable place holder)\nNone\nx = None\n\n\n\n\n\nNote two things from the above table:\n\nthe literal occurs through assignment, and\nthe constructor can be used to coerce one data type into another.\n\n\n\nHere we assign an integer (3) to the object x .\n\n# int\nx = 3\nx\ntype(x)\n\nint\n\n\n\n\n\nNow let’s coerce the integer to a float using the constructor float(). float represent real numbers with both an integer and fractional component\n\n# float\nfloat(x)\nx\n\n3\n\n\nNote that behavior of the object being coerced depends both on the initial class and the output class.\n\n#int\nx=3\n\n# add a int + float = float\ntype(x+3.0)\n\nfloat\n\n\n\n\n\nBoolean objects that are equal to True are truthy (True), and those equal to False are falsy (False). Numerically, int values equal to zero are False, and larger than zero are True\n\n# literal\nx=True\n\n#constructor\nbool(0)\n\nFalse\n\n\n\n\n\nFinally, all scalar data types are immutable, meaning they can’t be changed after assignment. When we make changes to a data type, say by coercing it to be another type as we do above, we’re actually creating a new object. We can see this by looking at the object id.\n\nid() tells us the “identity” of an object. That shouldn’t mean anything to you. Just know that when an object id is the same, it’s referencing the same data in the computer. We’ll explore the implications of this when we look at copying.\n\n\nx = 4\nid(x) \n\n4298289120\n\n\nHere we coerce x to be a float and then look up its id(). As we can see, there is a new number associated with it. This means x is a different object after coercion.\n\nid(float(x))\n\n140314976681488\n\n\n\n\n\nPython knows how to behave given the methods assigned to the object when we create an instance. The methods dictate how different data types deal with similar operations (such as addition, multiplication, comparative evaluations, ect.).\nUsing what we learned from OOP, it means that for every class, we have specific methods. These methods can have specific names – any user-defined function – or they can same universal names (Magic or Dunder Methods). See the addition example with int instances.\n\n# create int\nx=4\n\n# add literally\nx + 4\n\n# what is happening under the hood? \nx.__add__(4)\n\n8\n\n\nEvery class has a self-contained __add__ methods. For this reason, the output of adding two int or an int and a float are different\n\n\n\n\nCollection Data Types\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\nExample\nMutable\nLiteral\nConstructor\n\n\n\n\nlist\nheterogeneous sequences of objects\n[1,\"2\",True]\n✓\nx = [\"c\",\"a\",\"t\"]\nx = list(\"cat\")\n\n\nstr\nsequences of characters\n\"A word\"\n✘\nx = \"12345\"\nx = str(12345)\n\n\ntuples\nheterogeneous sequence of objects\n(1,2)\n✘\nx = (1,2)\nx = tuple([1,2])\n\n\nsets\nunordered collection of distinct objects\n{1,2}\n✓\nx = {1,2}\nx = set([1,2])\n\n\ndicts\nassociative array of key/value mappings\n{\"a\": 1}\nkeys ✘values ✓\nx = {'a':1}\nx = dict(a = 1)\n\n\n\nEach built-in collection data type in Python is distinct in important ways. Recall that an object’s class defines how the object behaves with operators and its methods. I’ll explore some of the differences in behavior for each class type so we can see what this means in practice\n\n\n\nNote the column referring to Mutable and Immutable collection types. Simply put, mutable objects can be changed after it is created, immutable objects cannot be changed. All the scalar data types are immutable. Even when we coerced objects into a different class, we aren’t changing the existing object, we are creating a new one.\nSome collection types, however, allow us to edit the data values contained within without needing to create a new object. This can allow us to effectively use the computer’s memory. It can also create some problems down the line if we aren’t careful (see the tab on copies).\nIn practice, mutability means we can alter values in the collection on the fly.\n\nmy_list = [\"sarah\",\"susan\",\"ralph\",\"eddie\"]\nid(my_list)\n\n140315540564672\n\n\n\nmy_list[1] = \"josh\"\nmy_list\nid(my_list) # Still the same object, even though we changed something in it\n\n140315540564672\n\n\nImmutability, on the other hand, means that we cannot alter values after the object is created. Python will throw an error at us if we try.\n\nmy_tuple =(\"sarah\",\"susan\",\"ralph\",\"eddie\")\nmy_tuple[1] = \"josh\"\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\n\n\nLists allow for heterogeneous membership in the various object types. This means one can hold many different data types (even other collection types!). In a list, one can change items contained within the object after creating the instance.\n\nx = [1, 2.2, \"str\", True, None] \nx\n\n[1, 2.2, 'str', True, None]\n\n\nA list constructor takes in an iterable object as input. (We’ll delve more into what makes an object iterable when covering loops, but the key is that the object must have an .__iter__() method.)\n\nlist(\"This\")\n\n['T', 'h', 'i', 's']\n\n\nAt it’s core, a list is a bucket for collecting different types of information. This makes it useful for collecting data items when one needs to store them. For example, we can store multiple container types in a list.\n\na = (1,2,3,4) # Tuple\nb = {\"a\":1,\"b\":2} # Dictionary\nc = [1,2,3,4] # List\n\ntogether = [a,b,c] # Combine these different container objects into a single list\ntogether\n\n[(1, 2, 3, 4), {'a': 1, 'b': 2}, [1, 2, 3, 4]]\n\n\nA list class has a range of specific methods geared toward querying, counting, sorting, and adding/removing elements in the container. For a list of all the list methods, see here.\nLet’s explore some of the common methods used.\n\ncountry_list = [\"Russia\",\"Latvia\",\"United States\",\"Nigeria\",\"Mexico\",\"India\",\"Costa Rica\"]\n\nInserting values\nOption 1: use the .append() method.\n\ncountry_list.append(\"Germany\")\ncountry_list\n\n['Russia',\n 'Latvia',\n 'United States',\n 'Nigeria',\n 'Mexico',\n 'India',\n 'Costa Rica',\n 'Germany']\n\n\nOption 2: use the + (add) operator.\n\ncountry_list = country_list + ['Canada']\ncountry_list\n\n['Russia',\n 'Latvia',\n 'United States',\n 'Nigeria',\n 'Mexico',\n 'India',\n 'Costa Rica',\n 'Germany',\n 'Canada']\n\n\n\nAddition means “append”?: Recall that an objects class dictates how it behaves in place of different operators. A list object has a .__add__() method built into it that provides instructions for what the object should do when it encounters + operator. Likewise, when it encounters a * multiplication operator and so on. This is why it’s so important to know the class that you’re using. Different object classes == different behavior.\n\nYou can also combine list through the reference names\n\nmore_countries = [\"Brazil\", \"Argentina\"]\ncountry_list + more_countries\n\n['Russia',\n 'Latvia',\n 'United States',\n 'Nigeria',\n 'Mexico',\n 'India',\n 'Costa Rica',\n 'Germany',\n 'Canada',\n 'Brazil',\n 'Argentina']\n\n\nDeleting values\nOption 1: use the del operator + index.\n\n# Drop Latvia\ndel country_list[1]\ncountry_list\n\n['Russia',\n 'United States',\n 'Nigeria',\n 'Mexico',\n 'India',\n 'Costa Rica',\n 'Germany',\n 'Canada']\n\n\nOption 2: use the .remove() method\n\ncountry_list.remove(\"Nigeria\")\ncountry_list\n\n['Russia',\n 'United States',\n 'Mexico',\n 'India',\n 'Costa Rica',\n 'Germany',\n 'Canada']\n\n\nSorting values\n\ncountry_list.sort()\ncountry_list\n\n['Canada',\n 'Costa Rica',\n 'Germany',\n 'India',\n 'Mexico',\n 'Russia',\n 'United States']\n\n\n\n\n\nStrings are containers too. String elements can be accessed using an index, much like objects in a list (See the tab on indices and keys).\n\ns = \"This is a string\"\ns[:4]\n\n'This'\n\n\nThe literal for a string is quotations: '' or \"\". When layering quotations, one needs to opt for the quotation type different than the one used to instantiate the string object.\n\ns = 'This is a \"string\"'\nprint(s)\n\ns = \"This is a 'string'\"\nprint(s)\n\nThis is a \"string\"\nThis is a 'string'\n\n\nA Multiline string can be created using three sets of quotations. This is useful when writing documentation for a function.\n\ns2 = '''\nThis is a long string!\n    \n    With many lines\n    \n    Many. Lines.\n'''\nprint(s2)\n\n\nThis is a long string!\n    \n    With many lines\n    \n    Many. Lines.\n\n\n\nString are quite versatile in Python! In fact, many of the manipulations that we like to perform on strings, such as splitting text up (also known as “tokenizing”), cleaning out punctuation and characters we don’t care for, and changing the case (to name a few) are built into the string class method.\nFor example, say we wanted to convert a string to upper case.\n\nstr1 = \"the professor is here!\"\nstr1.upper()\n\n'THE PROFESSOR IS HERE!'\n\n\nOr remove words.\n\nstr1.replace(\"professor\",\"student\")\n\n'the student is here!'\n\n\nThis is just a taste. The best way to learn what we can do with a string is to use it. We’ll deal with strings all the time when dealing with public policy data. So keep in mind that the str data type is a powerful tool in Python. For a list of all the str methods, see here.\n\n\n\nLike a list, a tuple allows for heterogeneous membership among the various scalar data types. However, unlike a list, a tuple is immutable, meaning you cannot change the object after creating it.\nThe literal for a tuple is the parentheses ()\n\nmy_tuple = (1,\"a\",1.2,True)\nmy_tuple\n\n(1, 'a', 1.2, True)\n\n\nThe constructor is tuple(). Like the list constructor, tuple() an iterable object (like a list) as an input.\n\nmy_tuple = tuple([1,\"a\",1.2,True])\nmy_tuple\n\n(1, 'a', 1.2, True)\n\n\nTuples are valuable if you want a data value to be fixed, such as if it were an index on a data frame, denoting a unit of analysis, or key on a dictionary. Tuples pop up all the time in the wild when dealing with more complex data modules, like Pandas. So we’ll see them again and again.\nOne nice thing that tuples allow for is unpacking. Unpacking allows one to deconstruct the tuple object into named references (i.e. assign the values in the tuple to their own objects). This allows for flexibility regarding which objects we want when performing sequential operations, like iterating.\n\nmy_tuple = (\"A\",\"B\",\"C\")\n\n# Here we're unpacking the three values into their own objects\nobj1, obj2, obj3 = my_tuple \n\n# Now let's print each object\nprint(obj1)\nprint(obj2)\nprint(obj3)\n\nA\nB\nC\n\n\nAlso, like a list, a tuple can store different collection data types as well as the scalar types. For example, we can store multiple container types in a tuple.\n\na = (1,2,3,4) # Tuple\nb = {\"a\":1,\"b\":2} # Dictionary\nc = [1,2,3,4] # List\n\ntogether = (a,b,c) # Combine these different container objects into a single tuple\ntogether\n\n((1, 2, 3, 4), {'a': 1, 'b': 2}, [1, 2, 3, 4])\n\n\nFor a list of all the tuple methods, see here.\n\n\n\nA set is an unordered collection of unique elements (this just means there can be no duplicates). set is a mutable data type (elements can be added and removed). Moreover, the set methods allow for set algebra. This will come in handy if we want to know something about unique values and membership.\nThe literal for set is the brackets {}.1\n\nmy_set = {1,2,3,3,3,4,4,4,5,1}\nmy_set\n\n{1, 2, 3, 4, 5}\n\n\nThe constructor is set(). As before, it takes an iterable object as an input.\n\nnew_set1 = set([1,2,4,4,5])\nnew_set1\n\nnew_set2 = set(\"Georgetown\")\nnew_set2\n\n{'G', 'e', 'g', 'n', 'o', 'r', 't', 'w'}\n\n\nIn the above, we can see that order isn’t a thing for a set.\nWe can add elemets to a set using the .add() or .update() methods.\n\nmy_set.add(6)\nmy_set\n\nmy_set.update({8})\nmy_set\n\n{1, 2, 3, 4, 5, 6, 8}\n\n\nWhere a set really shines is with the set operations. Say we had a set of country names.\n\ncountries = {\"nigeria\",\"russia\",\"united states\",\"canada\"}\n\nAnd we wanted to see which countries from our set were in another set (say another data set). Not a problem for a set!\n\nother_data = {\"nigeria\",\"netherlands\",\"united kingdom\",\"canada\"}\n\nWhich countries are in both sets?\n\ncountries.intersection(other_data)\n\n{'canada', 'nigeria'}\n\n\nWhich countries are in our data but not in the other data?\n\ncountries.difference(other_data)\n\n{'russia', 'united states'}\n\n\nNote that values in a set cannot be accessed using an index.\n\nmy_set[1]\n\nTypeError: 'set' object is not subscriptable\n\n\nRather we either .pop() values out of the set.\n\nmy_set.pop()\n\n1\n\n\nOr we can .remove() specific values from the set.\n\nmy_set.remove(3)\nmy_set\n\n{2, 4, 5, 6, 8}\n\n\nFinally, note that sets can contain heterogeneous scalar types, but they cannot contain other mutable container data types.\n\nset_a = {.5,6,\"a\",None}\nset_a\n\n{0.5, 6, None, 'a'}\n\n\nIn set_b, the list object is mutable.\n\nset_b = {.5,6,\"a\",None,[8,5,6]}\n\nTypeError: unhashable type: 'list'\n\n\nAll this is barely scratching the surface of what we can do with sets. For a list of all the set methods, see here.\n\n\n\nA dictionary is the true star of the Python data types. dict is an associative array of key-value pairs. That means, we have some data (value) that we can quickly reference by calling its name (key). As we’ll see next week, this allows for a very efficient way to look data values, especially when the dictionary is quite large.\nThere is no intrinsic ordering to the keys, and keys can’t be changed once created (that is, the keys are immutable), but the values can be changed (assuming that the data type occupying the value spot is mutable, like a list). Finally, keys cannot be duplicated. Recall we’re going to use the keys to look up data values, so if those keys were the same, it would defeat purpose!\nThe literal for a dict is {:} as in {&lt;key&gt;:&lt;value&gt;}.\n\nmy_dict = {'a': 4, 'b': 7, 'c': 9.2}\nmy_dict\n\n{'a': 4, 'b': 7, 'c': 9.2}\n\n\nThe constructor is dict(). Note the special way we can designate the key value pairing when using the constructor.\n\nmy_dict = dict(a = 4.23, b = 10, c = 6.6)\nmy_dict\n\n{'a': 4.23, 'b': 10, 'c': 6.6}\n\n\nThe dict class has a number of methods geared toward listing the information contained within. To access the dict’s keys, use the .keys() method.\n\nmy_dict.keys()\n\ndict_keys(['a', 'b', 'c'])\n\n\nJust want the values? Use .values()\n\nmy_dict.values()\n\ndict_values([4.23, 10, 6.6])\n\n\nWant both? Use .items(). Note how the data comes back to us — as tuples nested in a list! This just goes to show you how intertwined the different data types are in Python.\n\nmy_dict.items()\n\ndict_items([('a', 4.23), ('b', 10), ('c', 6.6)])\n\n\nWe can combine dictionary with other data types (such as a list) to make an efficient and effective data structure.\n\ngrades = {\"John\": [90,88,95,86],\"Susan\":[87,91,92,89],\"Chad\":[56,None,72,77]}\n\nWe can use the keys for efficient look up.\n\ngrades[\"John\"]\n\n[90, 88, 95, 86]\n\n\nWe can also use the .get() method to get the values that correspond to a specific key.\n\ngrades.get(\"Susan\")\n\n[87, 91, 92, 89]\n\n\nUpdating Dictionaries\nWe can add new dictionary data entries using the .update() method.\n\nnew_entry = {\"Wendy\":[99,98,97,94]} # Another student dictionary entry with grades\ngrades.update(new_entry) # Update the current dictionary \ngrades\n\n{'John': [90, 88, 95, 86],\n 'Susan': [87, 91, 92, 89],\n 'Chad': [56, None, 72, 77],\n 'Wendy': [99, 98, 97, 94]}\n\n\nIn a similar fashion, we can update the dictionary directly by providing a new key entry and storing the data.\n\ngrades[\"Seth\"] = [66,72,79,81]\ngrades\n\n{'John': [90, 88, 95, 86],\n 'Susan': [87, 91, 92, 89],\n 'Chad': [56, None, 72, 77],\n 'Wendy': [99, 98, 97, 94],\n 'Seth': [66, 72, 79, 81]}\n\n\nOne can also drop keys by .pop()ing the key value pair out of the collection…\n\ngrades.pop(\"Seth\")\n\n[66, 72, 79, 81]\n\n\n…or deleting the key using the del operator.\n\ndel grades['Wendy']\ngrades\n\n{'John': [90, 88, 95, 86],\n 'Susan': [87, 91, 92, 89],\n 'Chad': [56, None, 72, 77]}\n\n\nLikewise, one can drop values by:\n\noverwriting the original data stored in the key\ndropping the key (and thus deleting the data value)\nclearing the dictionary (and deleting all the data values stored within. )\n\n\n# Example of using .clear()\ngrades.clear()\ngrades\n\n{}\n\n\nThis is barely scratching the surface. For a list of all the dict methods and all the things you can do with a dictionary, see here."
  },
  {
    "objectID": "lecture_notes/week-03/week-03_data_types.html#indices-keys",
    "href": "lecture_notes/week-03/week-03_data_types.html#indices-keys",
    "title": "Week 3: Intro to Python - OOP, Data Types, and Collectors",
    "section": "",
    "text": "Learning how to access the data types is a foundation of your fluency as a data scientist.\nAs you transition across different languages, keep track of accessing methods across different data types is actually quite challenging. You will definitely find yourself searching online many times for this. The important issue here is make an effort to understand general rules for acessing elements across languages and data types\n\n\nA first way to access elements in collectors is through their index position.\n\ndifferent from R, Python objects start its index at zero\n\n\n  # Define a list \n  x = [1, 2.2, \"str\", True, None]\n  \n  # first element in python\n  x[0]\n\n  # can see how many values are in our container with len()\n  len(x)\n  \n  # Can look up individual data values by referencing its location\n  x[3]\n  \n  # Python throws an error if we reference an index location that doesn't exist\n  x[7]\n  \n  # We use a negative index to count BACKWARDS in our collection data type.\n  x[-3]\n\nIndexError: list index out of range\n\n\nThis way to access data using index position is going to be very standard across a range of data type.\n\n# tuples\ntup = (1, 2, \"no\", True)\n\n# first element\ntup[0]\n\n# Last element\ntup[-1]\n\nTrue\n\n\n\n\n\nWe use the : operator to slice (i.e. select ranges of values). This works using the numerical indices we juat learned. Slicing in a nutshell goes like this :\n\n# To pull out values in position 1 and 2\nx[1:3]\n\n# When we leave left or right side blank, Python implicitly goes to the beginning or end\nx[:3]\nx[2:]\n\n# %% Keys -----------------------------------------\n\n  # Define a dictionary\n  grades = {\"John\":[90,88,95,86],\"Susan\":[87,91,92,89],\"Chad\":[56,None,72,77]}\n\n  # Unlike lists/tuples/sets, we use a key to look up a value in a dictionary\n  grades[\"John\"]\n  \n  # We can then index in the data structure housed in that key's value position\n  # as is appropriate for that data object\n  grades[\"John\"][1]\n\nIndentationError: unexpected indent (4043772330.py, line 11)"
  },
  {
    "objectID": "lecture_notes/week-03/week-03_data_types.html#copies",
    "href": "lecture_notes/week-03/week-03_data_types.html#copies",
    "title": "Week 3: Intro to Python - OOP, Data Types, and Collectors",
    "section": "",
    "text": "# Copies with mutable objects -----------------------\n\n# Create a list object\nx = [\"a\",\"b\",\"c\",\"d\"]\n\n# Dual assignment: when objects reference the same data.\nx = y\nprint(id(x)) \nprint(id(y))\n\n# If we make a change in one\ny[1] = \"goat\"\n\n# That change is reflected in the other\nprint(x)\n\n# Because these aren't independent objects\n\n# We can get around this issue by making **copies**\ny = x.copy() # Here y is a copy of x.\n# This duplicates the data in memory, so that y and x are independent. \n\n# Three ways to make a copy:\n# (1) Use copy method\ny = x.copy()\n# (2) Use constructor\ny = list(x)\n# (3) Slice it\ny = x[:]\n\n\n# Copies with nested objects -----------------------\nnested_list = [[1,2,3],[4,7,88],[69,21,9.1]]\n\n# Create a shallow copy\nnew_list = nested_list.copy()\n\n# This copy only works for the \"first layer\" in the nested data structure.\nnew_list[0][1] = 1000\nprint(nested_list)\n\n# Creating a deep copy\n#import copy\nnew_list = copy.deepcopy(nested_list)\n\nNameError: name 'y' is not defined"
  },
  {
    "objectID": "lecture_notes/week-03/week-03_data_types.html#iteration",
    "href": "lecture_notes/week-03/week-03_data_types.html#iteration",
    "title": "Week 3: Intro to Python - OOP, Data Types, and Collectors",
    "section": "",
    "text": "A basic building block of any program is to be to be able to repeat some code over and over again. Whether it is to collect data for a list of websites, apply some function to a sequence of dataframes, or retrieve information form a set of different models, we are often interested as data scientist in repeating a certain action through a sequence of unit. This process is called iteration and it is often performed using a loop function.\n\n\nIteration in a basic sense is simply taking one item at a time from a collection. We start at the beginning of the collection and mover through it until we reach the end. Any time we use a loop we are going over each and every item in collection\nIn python, we can iterator over any non-scaler class with an iter() associated method. Examples are:\n\nlists\nstrings\ndictionaries\nfile connections\ngrouped pandas df\n\n\n\n\n# create a list\nmy_list = [1, 2, 3, 4, 5]\n\n# iterate\nfor m in my_list:\n  print(m)\n\n1\n2\n3\n4\n5\n\n\n\n\n\n\n# create a list\nmy_string = \"Georgetown\"\n\n# iterate\nfor letter in my_string:\n  print(letter)\n\nG\ne\no\nr\ng\ne\nt\no\nw\nn\n\n\n\n\n\nAnother container with the type of sequences used to express arithmetic progression of integers\n\n# one value 0 to 10\nfor i in range(10):\n    print(i)\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nThe instance from a range() is just a simple iterator\n\n# create a range\niter_ = range(10)\niter_[0]\niter_[1]\n\n# we can convert to a list to see the object\nlist(iter_)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\n\nThe enumerate function converts an iterable object in a tuple with a index and the iterator\n\n# create a string\niterable = \"McCourt\"\n\n# enumerate\nfor index, letter in enumerate(iterable):\n  print(f'index = {index}; value == {letter}')\n\nindex = 0; value == M\nindex = 1; value == c\nindex = 2; value == C\nindex = 3; value == o\nindex = 4; value == u\nindex = 5; value == r\nindex = 6; value == t\n\n\n\n\n\n\nWe just learned in practive how loops work. Let’s break down a bit more so that we actually grasp what is going on behind the scenes here.\n\n\nFirst, let’s fully understand the syntax of a loop. A loop had the following syntax:\nfor &lt;var&gt; in &lt;iterable&gt;:\n    &lt;statement(s)&gt;\n\n&lt;iterable&gt;: is a collection of objects. This is the container through which our loop is navigating element-wise\n&lt;statement(s)&gt;: this is the juice. It is a sequence of code that describes what is the action our program wants to repeat for each component of the iterable. Notice, &lt;statements&gt; in the loop body are denoted by indentation, as with all Python control structures.\n&lt;var&gt;: it is a local value for every of the next element in  each time through the loop.\n\n\n\n\niterable is any object that contains the __iter__ methods. This method returns an “iterator” object. An iterator object has a special method called __next__(), which summons each item in the collection one at a time.\n\n# create a iterable\nmy_list = [\"UFPA\", \"UERJ\", \"UMD\", \"NYU\", \"Georgetown\"]\nprint(my_list)\n\n# convert to a iterator\niter(my_list)\nmy_list.__iter__()\n\n# iterate over the elements\niter_my_list = iter(my_list)\n\n# first\nnext(iter_my_list)\n\n# first\nnext(iter_my_list)\n\n# second\nnext(iter_my_list)\n\n# third\nnext(iter_my_list)\n\n# fourth\nnext(iter_my_list)\n\n# firth: stop iteration\nnext(iter_my_list)\n\n['UFPA', 'UERJ', 'UMD', 'NYU', 'Georgetown']\n\n\nStopIteration: \n\n\nSo what does a for loop do?\n\nThe for statement calls iter() on the container object (e.g. a list).\nThe function returns an iterator object that defines the method __next__() which accesses elements in the container one at a time.\nWhen there are no more elements, __next__() raises a StopIteration exception which tells the for loop to terminate.\n\n\n\n\n\nFor loops are literally iterations. While loops are all about repetitions. These loops are super useful when we have some target and want to keep our program running up to certain threeshold. For example, while loops are heavily used in maximization functions, in which we keep the algorithm running until our error function is at a minimum/maximum.\n\nx = 0\nwhile x &lt; 5:\n    print(\"This\")\n    x += 1\n\nThis\nThis\nThis\nThis\nThis\n\n\nRemember to increment your condition and avoid an infinite loop."
  },
  {
    "objectID": "lecture_notes/week-03/week-03_data_types.html#comparison-operators",
    "href": "lecture_notes/week-03/week-03_data_types.html#comparison-operators",
    "title": "Week 3: Intro to Python - OOP, Data Types, and Collectors",
    "section": "",
    "text": "Comparison operators check whether a relationship holds between two objects. Since the relationship either holds or doesn’t hold, these operators always return Boolean values. See below for a list of these operators\n\n\n\nOperator\nProperty\n\n\n\n\n==\n(value) equivalence\n\n\n&gt;\ngreater than\n\n\n&lt;\nstrictly less than\n\n\n&lt;=\nless than or equal\n\n\n&gt;\nstrictly greater than\n\n\n&gt;=\ngreater than or equal\n\n\n!=\nNot Equals\n\n\nis\nobject identity\n\n\nis not\nnegated object identity\n\n\nin\nmembership in\n\n\nnot in\nnegated membership in\n\n\n\n\n# Some examples\n\n# Comparisons\nx = 7\ny = 6\n\n# simple comparisons\nx &gt;= y\nx &gt; y\nx &lt; y\nx &lt;= y\n\n# \"in\" for contains\n\"d\" in [\"x\",\"a\",\"v\"]\n\nFalse\n\n\n\n\nAnother type of operators are those that take as input boolen types and return as outputs the data types. These are often super useful when we are working with recoding of multiple variables. See table below:\n\n\n\nOperator\nLogical Operation\n\n\n\n\nand\nConjunction\n\n\nor\nDisjunction\n\n\nnot\nNegation\n\n\n\n\n# examples\n\n# and\nTrue and False\n\n# or\nTrue  or False\n\nTrue\n\n\n\nAll this is barely scratching the surface For a in-depth discussion of comparison operators in python, see here."
  },
  {
    "objectID": "lecture_notes/week-03/week-03_data_types.html#conditional-statements",
    "href": "lecture_notes/week-03/week-03_data_types.html#conditional-statements",
    "title": "Week 3: Intro to Python - OOP, Data Types, and Collectors",
    "section": "",
    "text": "Any programming language needs statements that controls the sequence of execution of a particular piece of code. These statements are called control statements, and they enable you to write programs that can perform different actions based on different inputs or situations. A for loop is a type of of control statement.\nThe most common control statements are conditional statements. The name speaks by itself: these statements control when a program run conditional on meeting a certain criteria. The most popular conditional statements are if, elif, and else statements.\nThese statements have the following structure:\n\n\n\n\n\n\nWarning\n\n\n\nNotice the indentation in the code blocks of the conditional statements!"
  },
  {
    "objectID": "lecture_notes/week-03/week-03_data_types.html#footnotes",
    "href": "lecture_notes/week-03/week-03_data_types.html#footnotes",
    "title": "Week 3: Intro to Python - OOP, Data Types, and Collectors",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNote that this is very similar to the literal for a dictionary but in that data structure we define a key/value pair (see the dict tab)↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PPOL 5203 - Data Science I: Foundations",
    "section": "",
    "text": "This first course in the core data science sequence teaches Data Science for Public Policy (DSPP) students how to synthesize disparate, possibly unstructured data in order to draw meaningful insights. Topics covered include the fundamentals of object-oriented programming in Python; literate programming; an introduction to algorithms and data types; data wrangling, visualization, and extraction; an introduction to machine learning methods, and text analysis. In addition, students will be exposed to Git and Github for version control and reproducible research. The objective of the course is to teach students how incorporate data into their decision-making and analysis. No prior programming experience is assumed or required.\nThis is not the first time this course is taught at DSPP. For this reason, several of the materials here are borrowed from previous iterations of this PPOL 564 taught by Dr. Rebecca Johnson and Dr. Eric Dunford"
  },
  {
    "objectID": "index.html#course-description",
    "href": "index.html#course-description",
    "title": "PPOL 5203 - Data Science I: Foundations",
    "section": "",
    "text": "This first course in the core data science sequence teaches Data Science for Public Policy (DSPP) students how to synthesize disparate, possibly unstructured data in order to draw meaningful insights. Topics covered include the fundamentals of object-oriented programming in Python; literate programming; an introduction to algorithms and data types; data wrangling, visualization, and extraction; an introduction to machine learning methods, and text analysis. In addition, students will be exposed to Git and Github for version control and reproducible research. The objective of the course is to teach students how incorporate data into their decision-making and analysis. No prior programming experience is assumed or required.\nThis is not the first time this course is taught at DSPP. For this reason, several of the materials here are borrowed from previous iterations of this PPOL 564 taught by Dr. Rebecca Johnson and Dr. Eric Dunford"
  },
  {
    "objectID": "index.html#goals",
    "href": "index.html#goals",
    "title": "PPOL 5203 - Data Science I: Foundations",
    "section": "Goals",
    "text": "Goals\nAfter completing this course, the students will be able to:\n\nGeneral understanding of python’s object oriented programming syntax and data structures.\nCompetency using version control (Git/Github).\nLearn to manipulate and explore data with Pandas and other tools.\nGeneral understanding of analyzing algorithms and data structures.\nLearn to extract and process data from structured and unstructured sources.\nGet some intuition of modeling text data in Python.\nLearn the basics of machine learning as a modeling approach.\nLearn basics of using SQL to query databases."
  },
  {
    "objectID": "index.html#instructors-and-tas",
    "href": "index.html#instructors-and-tas",
    "title": "PPOL 5203 - Data Science I: Foundations",
    "section": "Instructors and TAs",
    "text": "Instructors and TAs\n\nInstructor: Professor Tiago Ventura\n\nPronouns: He/Him\nEmail: tv186@georgetown.edu\nOffice hours:\n\nTime: Every Thursday, 4pm - 6pm\nLocation: Old North, 312\n\n\n\n\n\n\n\n\nWhen should I go to your office hours?\n\n\n\n\n\n\nYou are all welcome to the office hours. You can come to the office hours to:\n\ndrink some coffee;\ntalk about soccer;\nAsk what I am doing research at;\nAsk any question about our class.\n\nAll are valid options! And no need to schedule time with me!\n\n\nTA: Sierra Sikorski (DSPP, Second Year)\n\nEmail: sps126@georgetown.edu@georgetown.edu\nOffice Hours:\n\nEvery Tuesday 2pm (in person, old north)\nEvery Wednesday 2pm (remote via Zoom)\n\n\n\n\nCourse Infra-structure\nClass Website: This class website will be used throughout the course and should be checked on a regular basis for lecture materials and required readings.\nClass Slack Channel: The class also has a dedicated slack channel. The channel serves as an open forum to discuss, collaborate, pose problems/questions, and offer solutions. Students are encouraged to pose any questions they have there as this will provide the professor and TA the means of answering the question so that all can see the response. If you’re unfamiliar with, please consult the following start-up tutorial https://get.slack.help/hc/en-us/articles/218080037-Getting-started-for-new-members. Please follow the invite link to be added to the Slack channel.\nCanvas: A Canvas site http://canvas.georgetown.edu will be used throughout the course and should be checked on a regular basis for announcements. Materials will be posted here, and not on canvas, or distributed in class or by e-mail. Support for Canvas is available at (202) 687-4949\nDatacamp: As part of this course, you will have access to a DataCamp classroom that you can use to take Datacamp modules for free. Datacamp courses can be a useful tool for you to practice the concepts we see in class. Although I will not assign specific courses for you,, you can use Datacamp courses to review the topics we cover in class. The lecture notes will cover in details all our in-class discussions. Datacamp courses will be considered additional material."
  },
  {
    "objectID": "slides/week-1.html#plans-for-today",
    "href": "slides/week-1.html#plans-for-today",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Plans for Today",
    "text": "Plans for Today\n\n\nData Science for Public Policy, Computational Social Science, or why are we here?!\nGoals of the course\nCourse Logistics\nIDEs\n\nJupyter\nQuarto\n\nIntroduction to Commandline"
  },
  {
    "objectID": "slides/week-1.html#rise-of-the-digital-information-age",
    "href": "slides/week-1.html#rise-of-the-digital-information-age",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Rise of the digital information age",
    "text": "Rise of the digital information age\n\n\n\n\n\n\n\n\n\n\n\nhttps://www.washingtonpost.com/wp-dyn/content/graphic/2011/02/11/GR2011021100614.html"
  },
  {
    "objectID": "slides/week-1.html#real-time-data-mobility-credit-card-usage-expenses",
    "href": "slides/week-1.html#real-time-data-mobility-credit-card-usage-expenses",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Real Time Data: Mobility, Credit Card Usage, Expenses…",
    "text": "Real Time Data: Mobility, Credit Card Usage, Expenses…"
  },
  {
    "objectID": "slides/week-1.html#social-media-data",
    "href": "slides/week-1.html#social-media-data",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Social Media Data",
    "text": "Social Media Data"
  },
  {
    "objectID": "slides/week-1.html#new-data-formats-image-text-videos..",
    "href": "slides/week-1.html#new-data-formats-image-text-videos..",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "New Data Formats: Image, text, videos..",
    "text": "New Data Formats: Image, text, videos.."
  },
  {
    "objectID": "slides/week-1.html#online-research",
    "href": "slides/week-1.html#online-research",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Online Research",
    "text": "Online Research"
  },
  {
    "objectID": "slides/week-1.html#powerful-computers",
    "href": "slides/week-1.html#powerful-computers",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Powerful Computers",
    "text": "Powerful Computers"
  },
  {
    "objectID": "slides/week-1.html#as-a-consequence",
    "href": "slides/week-1.html#as-a-consequence",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "As a consequence:",
    "text": "As a consequence:\n\nAbundance of data we can use for research and governments can use to make better decisions\n\nNovel research questions\nNew ways to answer old, long-standing research questions\n\nNew technologies also have social implications and can generate important policy questions.\n\nPrivacy issues\nUse of technology by bad actors.\nUse of technology by governments to censor/monitor citizens.\netc…\n\nPolicy scholars need to be equipped for these challenges"
  },
  {
    "objectID": "slides/week-1.html#an-example-merging-voter-files-with-twitter-data",
    "href": "slides/week-1.html#an-example-merging-voter-files-with-twitter-data",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "An example: Merging Voter Files with Twitter Data",
    "text": "An example: Merging Voter Files with Twitter Data"
  },
  {
    "objectID": "slides/week-1.html#what-it-looks-like",
    "href": "slides/week-1.html#what-it-looks-like",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "What it looks like…",
    "text": "What it looks like…"
  },
  {
    "objectID": "slides/week-1.html#all-the-steps-tools-....-so-far-...",
    "href": "slides/week-1.html#all-the-steps-tools-....-so-far-...",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "All the steps + Tools .... so far ...",
    "text": "All the steps + Tools .... so far ...\n\n\nStep 1: Processing 180M voter files ~ 5terabytes\n\nHPC + Python + Spark\n\nStep 2: Find Matches between voters and Twitter users and Neighboors\n\nHPC + Python\n\nStep 3: Estimate/Impute Ideology for voters and Neighboors\n\nJuggles across multiple dataset (census, precincts, twitter networks) + Python and R\n\nStep 4: Run the analysis\n\nR"
  },
  {
    "objectID": "slides/week-1.html#data-science-for-public-policy",
    "href": "slides/week-1.html#data-science-for-public-policy",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Data Science for Public Policy",
    "text": "Data Science for Public Policy\nData Scientist for Public Policy focuses on computational approaches to solve/understand Policy Problems.\n\nA part of a larger field on computational social scientist with a more policy-focus.\nWhat is social science? It refers to a domain of study - social phenomena:\n\nEncompasses many scales: human psychology, language, economic behavior, political systems, policy problems\nInvolve many approaches: qualitative interviews, statistical analysis, simulations\n\nWhat is Data Science?:\n\nUse often large-scale data + algorithms to answer questions"
  },
  {
    "objectID": "slides/week-1.html#reading",
    "href": "slides/week-1.html#reading",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Reading",
    "text": "Reading\n\nBit by Bit: Social Research in the Digital Age By Mathew Salganik\n\nIntroduction\nObserving Behavior"
  },
  {
    "objectID": "slides/week-1.html#goals-of-the-course",
    "href": "slides/week-1.html#goals-of-the-course",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Goals of the course",
    "text": "Goals of the course\n\nThe goal of this course is to teach you:\n\nComputational thinking: how to approach problems and devise solutions from a computational perspective.\nGet you started on Python and a bit of SQL for applied data science; lay the foundations for the remainder of the core sequence\nWorkflows and tools: Git/Github + Commandline."
  },
  {
    "objectID": "slides/week-1.html#logistics",
    "href": "slides/week-1.html#logistics",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Logistics",
    "text": "Logistics\n\nCommunication: via slack. Join the channel!\nAll materials: hosted on the class website: https://tiagoventura.github.io/ppol5203_fall_2023/\nSyllabus: also on the website.\nMy Office Hours: Every thursday from 4 to 6pm. Just stop by!\nCanvas: Only for communication! Materials will be hosted in the website!\nDatacamp: Additional exercises! I will not assign modules for you!"
  },
  {
    "objectID": "slides/week-1.html#ta",
    "href": "slides/week-1.html#ta",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "TA",
    "text": "TA\nSierra Sikorski\n\nEmail: sps126@georgetown.edu\nOffice Hours:\n\nEvery Tuesday 2pm (in person, old north)\nEvery Wednesday 2pm (remote via Zoom)"
  },
  {
    "objectID": "slides/week-1.html#evaluation",
    "href": "slides/week-1.html#evaluation",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Evaluation",
    "text": "Evaluation\n\n\n\nAssignment\nPercentage of Grade\n\n\n\n\nParticipation/Attendance\n5%\n\n\nCoding Discussion\n5%\n\n\nProblem sets\n50%\n\n\nFinal Project\n40%"
  },
  {
    "objectID": "slides/week-1.html#problem-sets",
    "href": "slides/week-1.html#problem-sets",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Problem Sets",
    "text": "Problem Sets\nIndividual submission through GitHub.\n\n\n\nAssignment\nDate Assigned\nDate Due\n\n\n\n\nNo. 1\nWeek 2\nBefore EOD of Friday of Week 3\n\n\nNo. 2\nWeek 4\nBefore EOD of Friday of Week 5\n\n\nNo. 3\nWeek 6\nBefore EOD of Friday of Week 7\n\n\nNo. 4\nweek 8\nBefore EOD of Friday of Week 9\n\n\nNo. 5\nNovember 10\nBefore EOD of Friday of Week 111"
  },
  {
    "objectID": "slides/week-1.html#final-project",
    "href": "slides/week-1.html#final-project",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Final Project",
    "text": "Final Project\n\nYou will work on randomly assigned groups!\nThe project is composed of three parts:\n\na 2 page project proposal: (which should be discussed and approved by me)\nan in-class presentation,\nA 10-page project report."
  },
  {
    "objectID": "slides/week-1.html#due-dates-and-points",
    "href": "slides/week-1.html#due-dates-and-points",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Due dates and Points:",
    "text": "Due dates and Points:\n\n\n\nRequirement\nDue\nLength\nPercentage\n\n\n\n\nProject Proposal\nOctober 31\n2 pages\n5%\n\n\nPresentation\nDecember 5\n10-15 minutes\n10%\n\n\nProject Report\nDecember 12\n10 pages\n25%"
  },
  {
    "objectID": "slides/week-1.html#chatgpt",
    "href": "slides/week-1.html#chatgpt",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "ChatGPT",
    "text": "ChatGPT\nYou are allowed to use ChatGPT as you would use google in this class. This means:\n\nDo not copy the responses from chatgpt – a lot of them are wrong or will just not run on your computer\nUse chatgpt as a auxiliary source.\nIf your entire homework comes straight from chatgpt, I will consider it plagiarism.\nIf you use chatgpt, I ask you to mention on your code how chatgpt worked for you."
  },
  {
    "objectID": "slides/week-1.html#about-me",
    "href": "slides/week-1.html#about-me",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "About me",
    "text": "About me\n\n\nProfessor Tiago Ventura (he/him)\n\nAssistant Professor at McCourt School.\nPolitical Science Ph.D.\nPostdoc at Center for Social Media and Politics at NYU.\nResearcher at Twitter.\n\nResearch Interests:\n\nSocial media and politics\nComputational methods\nFocus on Global South\n\nOutside of work, I enjoy watching soccer and reading sci-fi.\n\nSometimes I enjoy soccer while working!\nAnd I am from Brazil!"
  },
  {
    "objectID": "slides/week-1.html#quiz",
    "href": "slides/week-1.html#quiz",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Quiz!",
    "text": "Quiz!\nWhich programming language did I use the most at?\n\nPhD\nPostdoc\nTwitter"
  },
  {
    "objectID": "slides/week-1.html#your-turn",
    "href": "slides/week-1.html#your-turn",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Your turn!",
    "text": "Your turn!\n\nName\n(Briefly) what you were up to prior to the DSPP\nIf you could have any data source at your disposal, what would it be?"
  },
  {
    "objectID": "slides/week-1.html#jupyter",
    "href": "slides/week-1.html#jupyter",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Jupyter:",
    "text": "Jupyter:\nSee Jupyter Notebook in the Class Website"
  },
  {
    "objectID": "slides/week-1.html#quarto",
    "href": "slides/week-1.html#quarto",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Quarto",
    "text": "Quarto\nSee Quarto Notebook in the Class Website"
  },
  {
    "objectID": "slides/week-1.html#command-line",
    "href": "slides/week-1.html#command-line",
    "title": " PPOL 5203 - Data Science I: Foundations ",
    "section": "Command Line",
    "text": "Command Line\nSee Command Line Tutorial in the Class Website"
  },
  {
    "objectID": "problem_sets/ps02/ps_02_blank.html",
    "href": "problem_sets/ps02/ps_02_blank.html",
    "title": "Introduction to Pset 02",
    "section": "",
    "text": "PPOL 5203 Data Science I: Foundations  Problem Sets II Tiago Ventura"
  },
  {
    "objectID": "problem_sets/ps02/ps_02_blank.html#converting-a-list-to-an-array",
    "href": "problem_sets/ps02/ps_02_blank.html#converting-a-list-to-an-array",
    "title": "Introduction to Pset 02",
    "section": "",
    "text": "We provide you with a list names roles_list_of_lists\n\nA. Transform the roles_list_of_lists into a 2D numpy array; call it roles_array\nB. Print the shape/dimensions of roles_array\n\n\n## your code here\nroles_list_of_lists = [[\"Tiago\", \"Ventura\", \"Professor\"], \n                      [\"Jiaqin\", \"Wu\", \"Teaching Assistant\"]]\n\n# response"
  },
  {
    "objectID": "problem_sets/ps02/ps_02_blank.html#subsetting-arrays-using-truefalse-boolean-indicators-2-points",
    "href": "problem_sets/ps02/ps_02_blank.html#subsetting-arrays-using-truefalse-boolean-indicators-2-points",
    "title": "Introduction to Pset 02",
    "section": "",
    "text": "A. Create a boolean indicator for rows where the role (third column) == ‘Teaching Assistant’ and print that indicator\nB. Use that boolean indicator to subset roles_array store the array as roles_TA\nC. Print the roles_TA array and its dimensions (should be 2x2)\n\n\n## your code here\n\n\n## your code here\n\n\n## your code here"
  },
  {
    "objectID": "problem_sets/ps02/ps_02_blank.html#adding-to-an-array-2-points",
    "href": "problem_sets/ps02/ps_02_blank.html#adding-to-an-array-2-points",
    "title": "Introduction to Pset 02",
    "section": "",
    "text": "A. Use np.append (google the documentation) to add the following column with the netids of the two TA to the roles_TA array as the last column\nB. Store as role_TA_net\nC. Print the dimensions (should be 2x3)\n\n\n## column to add \nnetids = np.array([['yl1374']])\nprint(netids)\n\n[['yl1374']]\n\n\n\n## your code here\n\n\n## your code here\n\n(4,)\n\n\n\n\nThe 2-d array below gives you data with the number of goals scored by a country in six editions of the Fifa Soccer World Cup.\nHere is the data as a nested list\n\n# rows and columns\nrows = [\"Argentina\", \"Brazil\", \"Germany\", \"Spain\", \"France\", \"Japan\", \"Uruguay\"]\ncols = [\"1990\", \"1994\", \"1998\", \"2002\", \"2006\", \"2010\", \"2014\"]\n\n# matrix of goals\ngoals= [[8,10, 2, 11, 10, 10], \n         [11, 14, 18, 10, 9, 15], \n         [9, 8, 14 , 14, 16, 29],\n         [10, 8, 10, 9, 8, 4],  \n         [0, 15, 0, 9, 1, 12],\n         [0, 1, 5, 2, 4, 2],\n         [0, 0, 4, 0, 11, 4]]       \n\nUsing only numpy functions (don’t try to convert to a panda dataframe), give me the following:\n\n\nHow many goals each country scored summing across all the world cup editions?\n\n\nHow many goals were scored in each edition summing across all the countries?\n\n\nWhich country scored more goals?\n\n\nWhich world cup edition had more goals?\n\n\n\n# your code here\n\n'2010'"
  },
  {
    "objectID": "problem_sets/ps02/ps_02_blank.html#using-list-comprehension-to-keep-all-elements-transform-them-3-points",
    "href": "problem_sets/ps02/ps_02_blank.html#using-list-comprehension-to-keep-all-elements-transform-them-3-points",
    "title": "Introduction to Pset 02",
    "section": "",
    "text": "A. Create a new list—course_codes_ns– that removes the spaces in each course code— eg PPOL 506 should become PPOL506\nB. Print course_codes_ns\n\n\n## your code here\n\n['PPOL506', 'PPOL560', 'PPOL564', 'SOCI393']"
  },
  {
    "objectID": "problem_sets/ps02/ps_02_blank.html#using-list-comprehension-to-subset-a-list-3-points",
    "href": "problem_sets/ps02/ps_02_blank.html#using-list-comprehension-to-subset-a-list-3-points",
    "title": "Introduction to Pset 02",
    "section": "",
    "text": "A. using course_codes_ns, create a new list just with courses with ppol in the name; store it as course_codes_ppol\n\n\n## your code here\n\n['PPOL506', 'PPOL560', 'PPOL564']"
  },
  {
    "objectID": "problem_sets/ps02/ps_02_blank.html#dictionary-comprehension",
    "href": "problem_sets/ps02/ps_02_blank.html#dictionary-comprehension",
    "title": "Introduction to Pset 02",
    "section": "",
    "text": "A. Create a second list with the grades you which to have in each of these courses\nB. Use a dictionary Comprehension to create a dictionary with keys for the course number, and values for your grade\nC. Convert the dictionary to a pandas dataframe\n\n\n## your code here\n\n{'PPOL 506': 'A+', 'PPOL 560': 'A+', 'PPOL 564': 'A', 'SOCI 393': 'C'}"
  },
  {
    "objectID": "problem_sets/ps02/ps_02_blank.html#generators-30pts",
    "href": "problem_sets/ps02/ps_02_blank.html#generators-30pts",
    "title": "Introduction to Pset 02",
    "section": "",
    "text": "In class, I argued that generators are extremely memory-efficient tool to build repeated tasks in Python. This happens because a generator is a special kind of function that leverages lazy evaluation, and do not store their contents in memory as you would expect a typical iterable to do. Instead, it only computes the element on demand.\nBeing suspicious of non-evidence based claim as a data scientist needs to be, you decided to write code to verify this assumption.\nSo prove to me with your code that iterating over range(N) is indeed more efficient in memory aspects than iterating of a list(N) object of the same size.\n\nTip: you can use the function sys.getsizeof() from the module sys to calcule the size of a object in Python"
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Syllabus: PPOL 5203 - Data Science I: Foundations",
    "section": "",
    "text": "This first course in the core data science sequence teaches Data Science for Public Policy (DSPP) students how to synthesize disparate, possibly unstructured data in order to draw meaningful insights. Topics covered include the fundamentals of object-oriented programming in Python; literate programming; an introduction to algorithms and data types; data wrangling, visualization, and extraction; an introduction to machine learning methods, and text analysis. In addition, students will be exposed to Git and Github for version control and reproducible research. The objective of the course is to teach students how incorporate data into their decision-making and analysis. No prior programming experience is assumed or required.\nClass Website: https://tiagoventura.github.io/ppol5203_fall_2023"
  },
  {
    "objectID": "syllabus.html#course-description",
    "href": "syllabus.html#course-description",
    "title": "Syllabus: PPOL 5203 - Data Science I: Foundations",
    "section": "",
    "text": "This first course in the core data science sequence teaches Data Science for Public Policy (DSPP) students how to synthesize disparate, possibly unstructured data in order to draw meaningful insights. Topics covered include the fundamentals of object-oriented programming in Python; literate programming; an introduction to algorithms and data types; data wrangling, visualization, and extraction; an introduction to machine learning methods, and text analysis. In addition, students will be exposed to Git and Github for version control and reproducible research. The objective of the course is to teach students how incorporate data into their decision-making and analysis. No prior programming experience is assumed or required.\nClass Website: https://tiagoventura.github.io/ppol5203_fall_2023"
  },
  {
    "objectID": "syllabus.html#learning-goals",
    "href": "syllabus.html#learning-goals",
    "title": "Syllabus: PPOL 5203 - Data Science I: Foundations",
    "section": "Learning Goals",
    "text": "Learning Goals\nAfter completing this course, the students will be able to:\n\nGeneral understanding of python’s object oriented programming syntax and data structures.\nCompetency using version control (Git/Github).\nLearn to manipulate and explore data with Pandas and other tools.\nGeneral understanding of analyzing algorithms and data structures.\nLearn to extract and process data from structured and unstructured sources.\nGet some intuition of modeling text data in Python.\nLearn the basics of machine learning as a modeling approach.\nLearn basics of using SQL to query databases."
  },
  {
    "objectID": "syllabus.html#instructors-and-tas",
    "href": "syllabus.html#instructors-and-tas",
    "title": "Syllabus: PPOL 5203 - Data Science I: Foundations",
    "section": "Instructors and TAs",
    "text": "Instructors and TAs\n\nInstructor\n\nProfessor: Dr. Tiago Ventura\nPronouns: He/Him\nEmail: tv186@georgetown.edu\nOffice hours:\n\nTime: Every Thursday, 4pm - 6pm\nLocation: Old North, 312"
  },
  {
    "objectID": "syllabus.html#teaching-assistant-sierra-sikorski-dspp-second-year-student",
    "href": "syllabus.html#teaching-assistant-sierra-sikorski-dspp-second-year-student",
    "title": "Syllabus: PPOL 5203 - Data Science I: Foundations",
    "section": "Teaching Assistant: Sierra Sikorski (DSPP Second-Year Student)",
    "text": "Teaching Assistant: Sierra Sikorski (DSPP Second-Year Student)\n\nEmail: sps126@georgetown.edu@georgetown.edu\nOffice Hours:\n\nEvery Tuesday 2pm (in person, old north)\nEvery Wednesday 2pm (remote via Zoom)"
  },
  {
    "objectID": "syllabus.html#our-classes",
    "href": "syllabus.html#our-classes",
    "title": "Syllabus: PPOL 5203 - Data Science I: Foundations",
    "section": "Our classes",
    "text": "Our classes\nClasses will take place at the scheduled class time/place and will involve a combination of lectures, coding walkthrough, breakout group sessions, and questions. We will start our classes with a lecture highlighting what I consider to be the broader substantive and programming concepts covered in the class. From that, we will switch to a mix of coding walk through and breakout group sessions.\nFor every lecture, you will have access to a notebook (in .qmd or .ipynb) covering the topics and code discussed in class. I will upload these materials (which I call lecture notes every day before the class starts). In addition, you will also have access (in at least a week in advance), of required readings (book chapters, articles, blog posts or coding tutorials) for every class. What you will take from this class will be tremendously improved if you work through all these materials.\nNote that this class is scheduled to meet weekly for 2.5 hours. I will do my best to make our meetings dynamic and enjoyable for all parts involved. We will take one or two breaks in each of our lecture."
  },
  {
    "objectID": "syllabus.html#required-materials",
    "href": "syllabus.html#required-materials",
    "title": "Syllabus: PPOL 5203 - Data Science I: Foundations",
    "section": "Required Materials",
    "text": "Required Materials\nReadings: We will rely primarily on the following text for this course.\n\nMcKinney, W. , 2022. Python for Data Analysis. O’Reilly Media, Inc.(Online version: https://wesmckinney.com/book/).\nVanderplas, J.T., 2016. “Python data science handbook: tools and techniques for developers.” O’Reilly. (Online version: https://jakevdp.github.io/PythonDataScienceHandbook/)\nJames, G., Witten, D., Hastie, T., & Tibshirani, R. (2013). “An Introduction to Statistical Learning: with Applications in R”. New York: springer.\nGrimmer, J., Roberts, M. E., & Stewart, B. M. (2022). Text as data: A new framework for machine learning and the social sciences. Princeton University Press.\nSalganik, M. 2017. Bit by Bit: Social Research in the Digital Age. Princeton, NJ: Princeton University Press.\n\nAdditional readings will be posted for each class and can be found on the course website. Most reading materials are open source and available via a link on the weekly schedule. Otherwise it can be found on Canvas."
  },
  {
    "objectID": "syllabus.html#course-infrastructure",
    "href": "syllabus.html#course-infrastructure",
    "title": "Syllabus: PPOL 5203 - Data Science I: Foundations",
    "section": "Course Infrastructure",
    "text": "Course Infrastructure\nClass Website: A class website https://tiagoventura.github.io/ppol5203_fall_2023 will be used throughout the course and should be checked on a regular basis for lecture materials and required readings.\nClass Slack Channel: The class also has a dedicated slack channel (ppol-564-fall-2023.slack.com). The channel serves as an open forum to discuss, collaborate, pose problems/questions, and offer solutions. Students are encouraged to pose any questions they have there as this will provide the professor and TA the means of answering the question so that all can see the response. If you’re unfamiliar with, please consult the following start-up tutorial (https://get.slack.help/hc/en-us/articles/218080037-Getting-started-for-new-members). Please follow the invite link to be added to the Slack channel.\nCanvas: A Canvas site (http://canvas.georgetown.edu) will be used throughout the course and should be checked on a regular basis for announcements. ll announcements for the assignments and classes will be posted on Canvas; they will not be distributed in class or by e-mail. Support for Canvas is available at (202) 687-4949\nNOTE: Students are encouraged to run lecture code on their own machines. If you do not have access to a laptop on which you can install python3, please contact the professor and/or TA for assistance. Only python3 will be used in this course."
  },
  {
    "objectID": "syllabus.html#weekly-schedule",
    "href": "syllabus.html#weekly-schedule",
    "title": "Syllabus: PPOL 5203 - Data Science I: Foundations",
    "section": "Weekly Schedule",
    "text": "Weekly Schedule\n\n\n\n\n\n\nWeek\n\n\nTopic\n\n\nDate\n\n\n\n\n\n\nWeek 01\n\n\nIntroduction, Installations, IDEs, Command line\n\n\nAugust 29, 2023\n\n\n\n\nWeek 02\n\n\nVersion Control, Workflow and Reproducibility: Or a bit of Git & GitHub\n\n\nSeptember 12, 2023\n\n\n\n\nWeek 03\n\n\nIntro to Python - OOP, Data Types, Control Statements and Functions\n\n\nSeptember 19, 2023\n\n\n\n\nWeek 04\n\n\nFrom Nested Lists to Data Frames\n\n\nSeptember 26, 2023\n\n\n\n\nWeek 05\n\n\nPandas I: Data Manipulation\n\n\nOctober 03, 2023\n\n\n\n\nWeek 06\n\n\nPandas II: Advanced Manipulation and Visualization\n\n\nOctober 10, 2023\n\n\n\n\nWeek 07\n\n\nScrapping: Drawing from (Un-)Structured Data Sources\n\n\nOctober 17, 2023\n\n\n\n\nWeek 08\n\n\nText as data I: Data Mining\n\n\nOctober 24, 2023\n\n\n\n\nWeek 09\n\n\nIntroduction to Statistical Learning\n\n\nOctober 31, 2023\n\n\n\n\nWeek 10\n\n\nText as Data II: Topics + Supervised Models\n\n\nNovember 07, 2023\n\n\n\n\nWeek 11\n\n\nInvited Speaker: Introduction to Algorithms + Coding Interviews\n\n\nNovember 14, 2023\n\n\n\n\nWeek 12\n\n\nTraining Machines and collecting data with Selenium\n\n\nNovember 21, 2023\n\n\n\n\nWeek 13\n\n\nSQL + Spark\n\n\nNovember 28, 2023\n\n\n\n\nWeek 14\n\n\nPresentations of Final Projects\n\n\nDecember 05, 2023\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "syllabus.html#course-requirements",
    "href": "syllabus.html#course-requirements",
    "title": "Syllabus: PPOL 5203 - Data Science I: Foundations",
    "section": "Course Requirements",
    "text": "Course Requirements\n\n\n\nAssignment\nPercentage of Grade\n\n\n\n\nParticipation/Attendance\n5%\n\n\nCoding Discussion\n5%\n\n\nProblem sets\n50%\n\n\nFinal Project\n40%\n\n\n\nParticipation and Attendance (5%):\nData science is an cooperative endeavor, and it’s crucial to view your fellow classmates as valuable assets rather than rivals. Your performance in the following aspects will be considered when assessing this part of your grade:\n\nActive involvement during class sessions, fostering a dynamic learning environment.\nContributions made to your group’s ultimate project.\nAssisting classmates by addressing problem set queries through GitHub issues. Supporting your peers will enhance your evaluation in terms of teamwork and engagement\nAssisting classmates with slack questions, sharing interesting materials on slack, asking question, and anything that provides healthy contributtions to the course.\n\nCoding Discussion(5%)\nEvery class will involve some lecture time, and some coding time. The coding time will be divided between me showing you things, and you working on small problem sets. These problem sets are purposefully constructed to help you understand the concepts we go through in class. You participation and involvement in these group exercises will also be part of your grade.\nProblem Sets (50%)\nStudents will be assigned five problem sets over the course of the semesters. While you are encouraged to discuss the problem sets with your peers and/or consult online resources, the finished product must be your own work. The goal of the assignment is to reinforce the student’s comprehension of the materials covered in each section.\nThe problems sets will assess your ability to apply the concepts to data that is substantially messier, and problems that are substantially more difficult, than the ones in the coding discussion in class.\nI will distribute the assignment through a mix of canvas and github. The assignments can be in the form of a Jupyter Notebook (.ipynb) or Quarto (.qmd). Students must submit completed assignments as a rendered .html file and the corresponding source code (.ipynb or .qmd).\nThe assignments will be graded in accuracy and quality of the programming style. For instance, our grading team will be looking at:\n\n\nall code must run;\n\n\nsolutions should be readable\n\n\nCode should be thoroughly commented (the Professor/TA should be able to understand the codes purpose by reading the comment),\nCoding solutions should be broken up into individual code chunks in Jupyter/R Markdown notebooks, not clumped together into one large code chunk (See examples in class or reach out to the TA/Professor if this is unclear),\nEach student defined function must contain a doc string explaining what the function does, each input argument, and what the function returns;\n\n\nCommentary, responses, and/or solutions should all be written in Markdown and explain sufficiently the outpus.\n\n\nAll solutions must be completed in Python.\n\n\nThe follow schedule lays out when each assignment will be assigned.\n\n\n\nAssignment\nDate Assigned\nDate Due\n\n\n\n\nNo. 1\nWeek 2\nBefore EOD of Friday of Week 3\n\n\nNo. 2\nWeek 4\nBefore EOD of Friday of Week 5\n\n\nNo. 3\nWeek 6\nBefore EOD of Friday of Week 7\n\n\nNo. 4\nWeek 8\nBefore EOD of Friday of Week 10\n\n\nNo. 5\nWeek 10\nBefore EOD of Friday of Week 11\n\n\n\nFinal Project (40%): Data science is an applied field and the DSPP is particularly geared towards providing students the tools to make policy and substantive contributtions using data and recent computational developments. In this sense, it is fundamental that you understand how to conduct a complete analysis from collecting data, to cleaning and analyzing it, to presenting your findings. For this reason, a considerable part of your grade will come from a an independent data science project, applying concepts learned throughout the course.\nThe project is composed of three parts:\n\na 2 page project proposal: (which should be discussed and approved by me)\nan in-class presentation,\nA 10-page project report.\n\nDue dates and breakdowns for the project are as follows:\n\n\n\nRequirement\nDue\nLength\nPercentage\n\n\n\n\nProject Proposal\nOctober 31\n2 pages\n5%\n\n\nPresentation\nDecember 5\n10-15 minutes\n10%\n\n\nProject Report\nDecember 12\n10 pages\n25%\n\n\n\nImportant notes about the final project\n\nFor the project proposal, you need to schedule a 30min with me at least a week before the due date. For this meeting, I expect you to send me a draft of your ideas. We will do the group assignment and start scheduling meetings by week 4, I will share with you a calendar invite to organize our meetings.\nFor the presentation, You will have 10-15 minutes in our last class of the semester to present you project.\nTake the final project seriously. After you finish your Masters, in any path you take, you will need to show concrete examples of your portfolio. This is a good opportunity to start building it.\nYour groups will be randomly assigned.\n\nSubmission of the Final Project\nThe end product should be a github repository that contains:\n\nThe raw source data you used for the project. If the data is too large for GitHub, talk with me, and we will find a solution\nYour proposal\nA README for the repository that, for each file, describes in detail:\n\nInputs to the file: e.g., raw data; a file containing credentials needed to access an API\nWhat the file does: describe major transformations.\nOutput: if the file produces any outputs (e.g., a cleaned dataset; a figure or graph).\nA set of code files that transform that data into a form usable to answer the question you have posed in your descriptive research proposal.\nYour final 10 pages report (I will share a template later in the semester)\n\n\nOf course, no commits after the due date will be considered in the assessment."
  },
  {
    "objectID": "syllabus.html#grading",
    "href": "syllabus.html#grading",
    "title": "Syllabus: PPOL 5203 - Data Science I: Foundations",
    "section": "Grading",
    "text": "Grading\nCourse grades will be determined according to the following scale:\n\n\n\nLetter\nRange\n\n\n\n\nA\n95% – 100%\n\n\nA-\n91% – 94%\n\n\nB+\n87% – 90%\n\n\nB\n84% – 86%\n\n\nB-\n80% – 83%\n\n\nC\n70% – 79%\n\n\nF\n&lt; 70%\n\n\n\nGrades may be curved if there are no students receiving A’s on the non-curved grading scale.\nLate problem sets will be penalized a letter grade per day."
  },
  {
    "objectID": "syllabus.html#communication",
    "href": "syllabus.html#communication",
    "title": "Syllabus: PPOL 5203 - Data Science I: Foundations",
    "section": "Communication",
    "text": "Communication\n\nClass-relevant and/or coding-related questions, Slack is the preferred method of communication. Please use the general or the relevant channel for these questions.\nFor private questions concerning the class, email is the preferred method of communication. All email messages must originate from your Georgetown University email account(s). Please use a professional salutation, proper spelling and grammar, and patience in waiting for a response. The professor reserves the right to not respond to emails that are drafted inappropriately. Please email the professor and the TA directly rather than through the Canvas messaging system. Emails sent through CANVAS will be ignored.\nI will try my best to respond to all emails/slack questions within 24 hours of being sent during a weekday. I will not respond to emails/slack sent late Friday (after 5:00 pm) or during the weekend until Monday (9:00 am). Please plan accordingly if you have questions regarding current or upcoming assignments.\nOnly reach out to the professor or teaching assistant regarding a technical question, error, or issue after you made a good faith effort to debugging/isolate your problem prior to reaching out. Learning how to search for help online is a important skill for data scientists."
  },
  {
    "objectID": "syllabus.html#electronic-devices",
    "href": "syllabus.html#electronic-devices",
    "title": "Syllabus: PPOL 5203 - Data Science I: Foundations",
    "section": "Electronic Devices",
    "text": "Electronic Devices\nWhen meeting in-person: the use of laptops, tablets, or other mobile devices is permitted only for class-related work. Audio and video recording is not allowed unless prior approval is given by the professor. Please mute all electronic devices during class."
  },
  {
    "objectID": "syllabus.html#georgetown-policies",
    "href": "syllabus.html#georgetown-policies",
    "title": "Syllabus: PPOL 5203 - Data Science I: Foundations",
    "section": "Georgetown Policies",
    "text": "Georgetown Policies\n\nDisability\nIf you believe you have a disability, then you should contact the Academic Resource Center (arc@georgetown.edu) for further information. The Center is located in the Leavey Center, Suite 335 (202-687-8354). The Academic Resource Center is the campus office responsible for reviewing documentation provided by students with disabilities and for determining reasonable accommodations in accordance with the Americans with Disabilities Act (ASA) and University policies. For more information, go to http://academicsupport.georgetown.edu/disability/\n\n\nImportant Academic Policies and Academic Integrity\nMcCourt School students are expected to uphold the academic policies set forth by Georgetown University and the Graduate School of Arts and Sciences. Students should therefore familiarize themselves with all the rules, regulations, and procedures relevant to their pursuit of a Graduate School degree. The policies are located at: http://grad.georgetown.edu/academics/policies/\nApplied to this course, while I encourage collaboration on assignments and use of resources like StackOverflow, the problem sets will ask you to list who you worked on the problem set with and cite StackOverflow if it is the direct source of a code snippet.\n\nChatGPT\nIn the last year, the internet was inundated with popularization of Large Language Models, particularly the easy use of ChatGPT. As a Data Scientist, LLMs will be part of your daily work. I see ChatGPT as Google on steroids, so I assume ChatGPT will be part of your daily work in this course, and it is part of my work as a researcher.\nThat being said, ChatGPT does not replace your training as a data scientist. If you are using ChatGPT instead of learning, I consider you are cheating in the course. And most importantly, you are wasting your time and resources. So that’s our policy for using LLMs models in class:\n\nDo not copy the responses from chatgpt – a lot of them are wrong or will just not run on your computer.\nUse chatgpt as a auxiliary source.\nIf your entire homework comes straight from chatgpt, I will consider it plagiarism.\n\nIf you use chatgpt, I ask you to mention on your code how chatgpt worked for you.\n\n\n\nStatement on Sexual Misconduct\nGeorgetown University and its faculty are committed to supporting survivors and those impacted by sexual misconduct, which includes sexual assault, sexual harassment, relationship violence, and stalking. Georgetown requires faculty members, unless otherwise designated as confidential, to report all disclosures of sexual misconduct to the University Title IX Coordinator or a Deputy Title IX Coordinator. If you disclose an incident of sexual misconduct to a professor in or outside of the classroom (with the exception of disclosures in papers), that faculty member must report the incident to the Title IX Coordinator, or Deputy Title IX Coordinator. The coordinator will, in turn, reach out to the student to provide support, resources, and the option to meet. [Please note that the student is not required to meet with the Title IX coordinator.]. More information about reporting options and resources can be found on the Sexual Misconduct\nWebsite: https://sexualassault.georgetown.edu/resourcecenter\nIf you would prefer to speak to someone confidentially, Georgetown has a number of fully confidential professional resources that can provide support and assistance. These resources include: Health Education Services for Sexual Assault Response and Prevention: confidential email: sarp[at]georgetown.edu\nCounseling and Psychiatric Services (CAPS): 202.687.6985 or after hours, call (833) 960-3006 to reach Fonemed, a telehealth service; individuals may ask for the on-call CAPS clinician\nMore information about reporting options and resources can be found on the Sexual Misconduct Website.\n\n\nProvost’s Policy on Religious Observances\nGeorgetown University promotes respect for all religions. Any student who is unable to attend classes or to participate in any examination, presentation, or assignment on a given day because of the observance of a major religious holiday or related travel shall be excused and provided with the opportunity to make up, without unreasonable burden, any work that has been missed for this reason and shall not in any other way be penalized for the absence or rescheduled work. Students will remain responsible for all assigned work. Students should notify professors in writing at the beginning of the semester of religious observances that conflict with their classes. The Office of the Provost, in consultation with Campus Ministry and the Registrar, will publish, before classes begin for a given term, a list of major religious holidays likely to affect Georgetown students. The Provost and the Main Campus Executive Faculty encourage faculty to accommodate students whose bona fide religious observances in other ways impede normal participation in a course. Students who cannot be accommodated should discuss the matter with an advising dean."
  },
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Schedule",
    "section": "",
    "text": "Week\n\n\nTopic\n\n\nDate\n\n\n\n\n\n\nWeek 01\n\n\nIntroduction, Installations, IDEs, Command line\n\n\nAugust 29, 2023\n\n\n\n\nWeek 02\n\n\nVersion Control, Workflow and Reproducibility: Or a bit of Git & GitHub\n\n\nSeptember 12, 2023\n\n\n\n\nWeek 03\n\n\nIntro to Python - OOP, Data Types, Control Statements and Functions\n\n\nSeptember 19, 2023\n\n\n\n\nWeek 04\n\n\nFrom Nested Lists to Data Frames\n\n\nSeptember 26, 2023\n\n\n\n\nWeek 05\n\n\nPandas I: Data Manipulation\n\n\nOctober 03, 2023\n\n\n\n\nWeek 06\n\n\nPandas II: Advanced Manipulation and Visualization\n\n\nOctober 10, 2023\n\n\n\n\nWeek 07\n\n\nScrapping: Drawing from (Un-)Structured Data Sources\n\n\nOctober 17, 2023\n\n\n\n\nWeek 08\n\n\nText as data I: Data Mining\n\n\nOctober 24, 2023\n\n\n\n\nWeek 09\n\n\nIntroduction to Statistical Learning\n\n\nOctober 31, 2023\n\n\n\n\nWeek 10\n\n\nText as Data II: Topics + Supervised Models\n\n\nNovember 07, 2023\n\n\n\n\nWeek 11\n\n\nInvited Speaker: Introduction to Algorithms + Coding Interviews\n\n\nNovember 14, 2023\n\n\n\n\nWeek 12\n\n\nTraining Machines and collecting data with Selenium\n\n\nNovember 21, 2023\n\n\n\n\nWeek 13\n\n\nSQL + Spark\n\n\nNovember 28, 2023\n\n\n\n\nWeek 14\n\n\nPresentations of Final Projects\n\n\nDecember 05, 2023\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "schedule.html#weekly-schedule",
    "href": "schedule.html#weekly-schedule",
    "title": "Schedule",
    "section": "",
    "text": "Week\n\n\nTopic\n\n\nDate\n\n\n\n\n\n\nWeek 01\n\n\nIntroduction, Installations, IDEs, Command line\n\n\nAugust 29, 2023\n\n\n\n\nWeek 02\n\n\nVersion Control, Workflow and Reproducibility: Or a bit of Git & GitHub\n\n\nSeptember 12, 2023\n\n\n\n\nWeek 03\n\n\nIntro to Python - OOP, Data Types, Control Statements and Functions\n\n\nSeptember 19, 2023\n\n\n\n\nWeek 04\n\n\nFrom Nested Lists to Data Frames\n\n\nSeptember 26, 2023\n\n\n\n\nWeek 05\n\n\nPandas I: Data Manipulation\n\n\nOctober 03, 2023\n\n\n\n\nWeek 06\n\n\nPandas II: Advanced Manipulation and Visualization\n\n\nOctober 10, 2023\n\n\n\n\nWeek 07\n\n\nScrapping: Drawing from (Un-)Structured Data Sources\n\n\nOctober 17, 2023\n\n\n\n\nWeek 08\n\n\nText as data I: Data Mining\n\n\nOctober 24, 2023\n\n\n\n\nWeek 09\n\n\nIntroduction to Statistical Learning\n\n\nOctober 31, 2023\n\n\n\n\nWeek 10\n\n\nText as Data II: Topics + Supervised Models\n\n\nNovember 07, 2023\n\n\n\n\nWeek 11\n\n\nInvited Speaker: Introduction to Algorithms + Coding Interviews\n\n\nNovember 14, 2023\n\n\n\n\nWeek 12\n\n\nTraining Machines and collecting data with Selenium\n\n\nNovember 21, 2023\n\n\n\n\nWeek 13\n\n\nSQL + Spark\n\n\nNovember 28, 2023\n\n\n\n\nWeek 14\n\n\nPresentations of Final Projects\n\n\nDecember 05, 2023\n\n\n\n\n\n\nNo matching items"
  }
]